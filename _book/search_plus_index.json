{"./":{"url":"./","title":"简介","keywords":"","body":"数学笔记 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-08-18 08:35:17 "},"posts/matrix/derivative.html":{"url":"posts/matrix/derivative.html","title":"导数","keywords":"","body":"若方阵\\Av可逆，则 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff \\Av} = - \\Av^{-\\top} \\Bv^\\top \\Cv^\\top \\Av^{-\\top} \\end{align*} 证明：由矩阵乘法的线性性，易知有 \\begin{align*} \\frac{\\diff (\\Av \\Bv)}{\\diff x} = \\frac{\\diff \\Av}{\\diff x} \\Bv + \\Av \\frac{\\diff \\Bv}{\\diff x} \\end{align*} 特别地，取\\Bv = \\Av^{-1}且x = a_{ij}可知有 \\begin{align*} \\boldsymbol{0} = \\frac{\\diff \\Iv}{\\diff a_{ij}} = \\frac{\\diff (\\Av \\Av^{-1})}{\\diff a_{ij}} = \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} + \\Av \\frac{\\diff \\Av^{-1}}{\\diff a_{ij}} \\end{align*} 即 \\begin{align*} \\frac{\\diff \\Av^{-1}}{\\diff a_{ij}} = - \\Av^{-1} \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} \\end{align*} 注意\\tr (\\Bv \\Av^{-1} \\Cv) = \\tr (\\Av^{-1} \\Cv \\Bv)，于是 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff a_{ij}} & = \\frac{\\diff (\\tr(\\Av^{-1} \\Cv \\Bv))}{\\diff a_{ij}} = \\tr \\left( \\frac{\\diff (\\Av^{-1} \\Cv \\Bv)}{\\diff a_{ij}} \\right) \\\\ & = \\tr \\left( - \\Av^{-1} \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} \\Cv \\Bv \\right) = - \\tr \\left( \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} \\Cv \\Bv \\Av^{-1} \\right) \\end{align*} 注意\\diff \\Av / \\diff a_{ij}是一个(i,j)处为1其余均为0的矩阵，于是 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff a_{ij}} = - [\\Av^{-1} \\Cv \\Bv \\Av^{-1}]_{ji} \\end{align*} 写成矩阵的形式为 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff \\Av} = - \\Av^{-\\top} \\Bv^\\top \\Cv^\\top \\Av^{-\\top} \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-07-18 12:55:21 "},"posts/determinant/Cauchy-Binet.html":{"url":"posts/determinant/Cauchy-Binet.html","title":"Cauchy-Binet公式","keywords":"","body":"　　众所周知对于方阵\\Av、\\Bv有 \\begin{align} \\label{eq: det-product} \\det(\\Av \\Bv) = \\det(\\Av) \\det(\\Bv) \\end{align} 更一般的设\\Av \\in \\Rbb^{m \\times n}、\\Bv \\in \\Rbb^{n \\times m}，记S_{[n],m}为集合[n]的所有m元子集构成的集合，则 \\begin{align} \\label{eq: Cauchy-Binet} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align} 这就是Cauchy-Binet公式。 　　考虑三种情况： m = n，此时S_{[n],n}中只有一个元素，就是[n]，式(\\ref{eq: Cauchy-Binet})就退化成了式(\\ref{eq: det-product})； m > n，此时S_{[n],m}是个空集，因此式(\\ref{eq: Cauchy-Binet})等号右边的求和为零，而左边是个秩为n的m阶方阵，非满秩矩阵对应的行列式值为零； m ，举个简单的例子，n=3、m=2、S_{[n],m} = \\{ \\{1,2\\}, \\{2,3\\}, \\{1,3\\} \\}，此时有 \\begin{align*} \\left| \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\end{bmatrix} \\begin{bmatrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{bmatrix} \\right| = \\underbrace{\\left| \\begin{matrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\end{matrix} \\right|}_{S=\\{1,2\\}} + \\underbrace{\\left| \\begin{matrix} a_{12} & a_{13} \\\\ a_{22} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{2,3\\}} + \\underbrace{\\left| \\begin{matrix} a_{11} & a_{13} \\\\ a_{21} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{1,3\\}} \\end{align*} 　　下面给出一个简单的证明，记\\Av的列分别为\\av_1, \\ldots, \\av_n，则 \\begin{align*} \\Av \\Bv = \\begin{bmatrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{bmatrix} \\end{align*} 即\\Av \\Bv的每一列都是\\av_1, \\ldots, \\av_n的线性组合。下面依次展开每一列，易知 \\begin{align*} \\det(\\Av \\Bv) & = | \\begin{matrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\\\ & = b_{11} | \\begin{matrix} \\av_1 & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n1} | \\begin{matrix} \\av_n & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\end{align*} 接着展开第二列，易知上式右边的每一项又会拆分成n项，即 \\begin{align*} \\forall k \\in [n], \\quad & b_{k1} | \\begin{matrix} \\av_k & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | = b_{k1} (b_{12} | \\begin{matrix} \\av_k & \\av_1 & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n2} | \\begin{matrix} \\av_k & \\av_n & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} |) \\end{align*} 最终全部m列展开完毕，将会得到n^m项： \\begin{align*} \\det(\\Av \\Bv) = \\sum_{\\phi} b_{\\phi(1),1} b_{\\phi(2),2} \\cdots b_{\\phi(m),m} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | \\end{align*} 其中\\phi是[m] \\mapsto [n]的映射，求和遍历所有这样的映射。注意若行列式两列相同，行列式值为零，因此实际我们只需考虑单射，这样上式的求和项中就只剩下A_n^m项。 　　对于任一满足\\phi(1) 的项，显然它的行列式中的部分是\\Av的某个m阶子方阵，故 \\begin{align*} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = \\det(\\Av_{[m], S}) \\end{align*} 其中S = \\{\\phi(1), \\phi(2), \\ldots, \\phi(m)\\}。现考虑其它行列式也由\\av_{\\phi(1)}, \\ldots, \\av_{\\phi(m)}构成的项，这样的项有m!个，均呈型 \\begin{align*} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | \\end{align*} 其中\\sigma是S \\mapsto S的置换，由于行列式交换两列，值不变符号取反，因此 \\begin{align*} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} \\det(\\Av_{[m], S}) \\end{align*} 其中\\sgn (\\sigma)是\\sigma产生的逆序对的个数。所有这样的项求和为 \\begin{align*} \\left( \\sum_{\\sigma} (-1)^{\\sgn (\\sigma)} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} \\right) \\det(\\Av_{[m], S}) \\end{align*} 注意括号中的部分就是\\Bv的第\\phi(1), \\ldots, \\phi(m)行构成的m阶子方阵的行列式展开，因此上式等于 \\begin{align*} \\det(\\Av_{[m], S}) \\det(\\Bv_{S,[m]}) \\end{align*} 取遍C_n^m个这样单调递增的\\phi即可得 \\begin{align*} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-07-09 08:55:45 "},"posts/measure/set-algebra.html":{"url":"posts/measure/set-algebra.html","title":"集合代数","keywords":"","body":"　　对于定积分 \\begin{align*} \\int_a^b f(x) \\diff x \\end{align*} Riemann积分对定义域区间[a,b]进行切分a = a_0 ，然后用上和 \\begin{align*} US = \\sum_{i \\in [n]} \\sup \\{ f(x): x \\in [a_{i-1}, a_i] \\} (a_i - a_{i-1}) \\end{align*} 与下和 \\begin{align*} LS = \\sum_{i \\in [n]} \\inf \\{ f(x): x \\in [a_{i-1}, a_i] \\} (a_i - a_{i-1}) \\end{align*} 对积分值进行夹逼 \\begin{align*} LS \\leq \\int_a^b f(x) \\diff x \\leq US \\end{align*} 　　随着切分越来越细，上和单调减，下和单调增，当积分函数f连续时，两者极限相等且等于积分值，但是当f(非常)不连续时，Riemann积分就会出问题了，比如对Dirichlet函数 \\begin{align*} f(x) = \\begin{cases} 1 & x \\in \\Qbb \\\\ 0 & \\ow \\end{cases} \\end{align*} 无论怎么对定义域切分，下和总是0，上和总是1，极限不相等。为了解决此类问题，Lebesgue积分采用对值域进行切分的方式，对于某个值域区间[a, b]，易知也有上和、下和夹逼： \\begin{align*} \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} a \\diff x \\leq \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} f(x) \\diff x \\leq \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} b \\diff x \\end{align*} 于是问题就转化为求集合\\{x : a \\leq f(x) \\leq b \\}的“长度”。 　　给集合赋予“长度”是Lebesgue测度论的核心问题，这个问题看似简单，其实很复杂，因为集合可能是无穷点集(上面Dirichlet函数的例子)，也可能是无穷个不相交小区间的并集(在(0,1]上对\\sin (1/x)积分)。事实上，不存在一个普适的长度函数能够对\\Rbb的任意子集都赋予长度，总有些稀奇古怪的异类需要剔除，因此我们引入集合代数的概念，通过定义一些规则，导出一类性质良好可以赋予长度的集合。 　　设\\Omega为非空集合，\\Acal \\subseteq \\Pcal(\\Omega)为其子集构成的集合，对前面的一维积分问题，\\Omega就是\\Rbb，但测度论并不局限于一维积分。例如对n维积分，\\Omega是\\Rbb^n；对概率论，\\Omega是基础事件集合。因此为了保持结论的一般性，我们不将全集写为\\Rbb。 　　集合代数中最简单的结构是环(ring)，其满足三个条件：(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭。这个名字不是随便乱起的，因为定义加法为对称差\\Delta、乘法为交\\cap，(\\Acal, \\Delta, \\cap)就构成了抽象代数里的(交换)环，具体可参见此文。 　　若将环的后两个条件弱化可得到半环(semiring)，其满足：(1).\\emptyset \\subseteq \\Acal；(2).对于\\forall A, B \\in \\Acal，A \\setminus B是\\Acal中有限个不相交集合的并；(3).\\Acal关于\\cap封闭。 　　由于\\cup封闭可保证半环的第二个条件始终满足，而\\setminus封闭可导出\\cap封闭： \\begin{align*} X \\setminus (X \\setminus Y) = X \\setminus (X \\cap \\complement Y) = X \\cap \\complement (X \\cap \\complement Y) = X \\cap (\\complement X \\cup Y) = X \\cap Y \\end{align*} 因此环肯定是半环。但反过来不成立，例如\\Rbb上的全部左开右闭区间构成的集合 \\begin{align*} \\Acal = \\{ (a,b] \\mid a,b \\in \\Rbb, a \\leq b \\} \\end{align*} 就是一个半环，但不是环(关于\\cup不封闭)。事实上，如果半环关于\\cup封闭，则结合第二个条件“A \\setminus B是\\Acal中有限个不相交集合的并”可导出“A \\setminus B是\\Acal中元素”，即关于\\setminus封闭，半环升级成环。 　　若将环的第一个条件改成全集\\Omega \\in \\Acal，则得到代数(algebra)，其满足：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭。 　　由于\\emptyset = (\\Omega \\setminus \\Omega) \\in \\Acal，因此代数肯定是环，但反过来不成立，例如\\Rbb上的全部有界区间的有限并(finite unions)构成的集合就是一个环，但不是代数(全集\\Omega = \\Rbb不属于该集合，因为它无法写成有界区间的有限并)。更一般的，设全集为不可数集合，则其所有可数子集构成的集合就只是环而不是代数。环升级成代数的方法也很简单：先加入全集，然后加入必要的保证\\setminus、\\cup封闭的新元素即可。 　　由于全集的存在，\\setminus封闭可导出\\complement封闭，而由De Morgan律： \\begin{align*} X \\cap Y & = \\complement \\complement (X \\cap Y) = \\complement (\\complement X \\cup \\complement Y) \\\\ X \\cup Y & = \\complement \\complement (X \\cup Y) = \\complement (\\complement X \\cap \\complement Y) \\end{align*} 即在\\complement封闭的前提下，\\cap封闭、\\cup封闭可以互推。又A \\setminus B = A \\cap \\complement B，因此\\cap、\\complement封闭可以导出\\setminus封闭，于是若全集存在，则有 \\begin{align*} \\setminus, \\cup \\text{封闭} \\Longleftrightarrow \\complement, \\cap \\text{封闭} \\Longleftrightarrow \\complement, \\cup \\text{封闭} \\end{align*} 故代数也可等价定义为：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\complement封闭；(3).\\Acal关于\\cap或\\cup封闭。 　　虽然环以\\Delta为加法、\\cap为乘法可构成抽象代数里的交换环(该方式也是唯一的)，但是代数以\\Delta为加法、\\cap为乘法却没有对应的抽象代数结构，易知 \\begin{align*} A \\cap \\Omega = A, \\quad A \\cap \\emptyset = \\emptyset \\end{align*} 即全集\\Omega是乘法运算的单位元，空集\\emptyset是乘法运算的零元(这是环就有的)，但其它非零元素没有乘法逆元，设A \\in \\Acal为非空集，显然不存在其它集合与A的交集等于全集(单位元)，因此代数无法构成抽象代数里的域。 　　前面提到在(0,1]上对\\sin (1/x)积分时，集合\\{x : a \\leq f(x) \\leq b \\}是无穷个不相交小区间的并集，因此我们也要允许可数次并这样的操作，这样就导出了\\sigma-环，其满足：(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于可数次\\cup封闭；以及\\sigma-代数，其满足：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于可数次\\cup封闭。\\sigma-代数也被称为\\sigma-域，但前文表明代数并不对应抽象代数里的域，因此我不喜欢这样的叫法，容易产生误解。\\sigma-环、\\sigma-代数的关系与环、代数的关系一样，前者加入全集，然后再加入必要的保证\\setminus、\\cup封闭的新元素即可得到后者。 　　综上，半环、环、代数、\\sigma-环、\\sigma-代数之间的关系如下： 　　测度论一般采用\\sigma-代数作为考虑对象，即对\\sigma-代数中的任一集合赋予长度。具体到一维积分，这意味着全集\\Rbb是有长度的，若A \\subseteq \\Rbb是\\sigma-代数中的集合，即可以赋予长度，那么\\Rbb \\setminus A也是可以赋予长度的，若A_1, A_2, \\ldots可以赋予长度，那么其并集也可以赋予长度。 　　采用别的结构作为基础建立测度论也不是不可以，只是没有\\sigma-代数那么好用。比如函数f可测的定义是对任意Borel集B \\subseteq \\Rbb，逆象f^{-1} (B) \\in \\Sigma，其中\\Sigma是一个\\sigma-代数。若在\\sigma-环\\Sigma_r上沿用此定义，即对任意Borel集B \\subseteq \\Rbb有f^{-1} (B) \\in \\Sigma_r。由于全集\\Omega = f^{-1} (\\Rbb)，因此要么\\Sigma_r包含全集从而是一个\\sigma-代数，要么任何函数都不可测。若修正定义为对任意Borel集B \\subseteq \\Rbb有\\{ x: f(x) \\neq 0 \\} \\cap f^{-1}(B) \\in \\Sigma_r，此时可避免所有函数不可测的情况，因为即便B = \\Rbb，即f^{-1}(B) = \\Omega，第一项可能会小于全集。但是注意到对任意非零常数函数f，均有\\{ x: f(x) \\neq 0 \\} = \\Omega，因此所有的非零常数函数都是不可测的，进一步这会导出即便f可测，f+1也还是不可测这样反直觉的结果。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-08-18 22:22:05 "},"posts/measure/set-ring-algebra-ring.html":{"url":"posts/measure/set-ring-algebra-ring.html","title":"此环非彼环乎？","keywords":"","body":"　　学测度论时会碰到某个非空集合\\Omega的子集构成的集合\\Acal \\subseteq \\Pcal(\\Omega)，当其满足(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭，称为环(ring)。众所周知抽象代数里有个数学结构也叫环，其上定义了加法、乘法两个二元运算，并且关于加法构成交换群(commutative group)，关于乘法构成半群(semigroup)，乘法对加法满足分配律。 　　为了区别，下面我们称前者为集合环，后者为代数环。本文说明两者的关系是\\Acal能通过赋予合适的集合上的加法、乘法构成代数(交换)环当且仅当\\Acal是集合环。 　　\\Leftarrow较为简单，给出具体的加法、乘法定义再验证满足代数环公理即可。定义集合环\\Acal中的加法为对称差： \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X), \\quad \\forall X, Y \\in \\Acal \\end{align*} 不难验证(\\Acal, \\Delta)构成交换群，其中交换律是显然的，封闭性由集合环关于\\setminus、\\cup封闭保证，又 \\begin{align*} X \\Delta \\emptyset & = (X \\setminus \\emptyset) \\cup (\\emptyset \\setminus X) = X \\\\ X \\Delta X & = (X \\setminus X) \\cup (X \\setminus X) = \\emptyset \\end{align*} 因此\\emptyset是单位元，逆元就是自身，结合律(X \\Delta Y) \\Delta Z = X \\Delta (Y \\Delta Z)通过集合运算进行验证较为繁琐，根据下面的Venn图易知其成立。 　　定义乘法为\\cap，于是交换律、结合律都是显然的，由于X \\setminus Y = X \\cap \\complement Y，因此 \\begin{align*} X \\setminus (X \\setminus Y) = X \\setminus (X \\cap \\complement Y) = X \\cap \\complement (X \\cap \\complement Y) = X \\cap (\\complement X \\cup Y) = X \\cap Y \\end{align*} 即封闭性也是满足的(这也说明集合环关于\\cup、\\cap、\\setminus都是封闭的)。 　　最后验证\\Delta对于\\cap满足分配律，由于 \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X) = (X \\cap \\complement Y) \\cup (Y \\cap \\complement X) = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\end{align*} 于是 \\begin{align*} (X \\Delta Y) \\cap Z & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\cap Z \\\\ & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y \\cup \\complement Z) \\cap Z \\\\ & = [(X \\cup Y) \\cap Z] \\cap [\\complement X \\cup \\complement Y \\cup \\complement Z] \\\\ & = [(X \\cap Z) \\cup (Y \\cap Z)] \\cap [\\complement (X \\cap Z) \\cup \\complement(Y \\cap Z)] \\\\ & = (X \\cap Z) \\Delta (Y \\cap Z) \\end{align*} 同理易知有 \\begin{align*} Z \\cap (X \\Delta Y) = Z \\cap (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) = (X \\cap Z) \\Delta (Y \\cap Z) = (Z \\cap X) \\Delta (Z \\cap Y) \\end{align*} 综上，若\\Acal \\subseteq \\Pcal(\\Omega)是集合环，则(\\Acal, \\Delta, \\cap)构成代数(交换)环。 　　\\Rightarrow较为复杂，因为我们不知道一个有望构成交换环的集合，它对应的加法、乘法分别是啥，所以我们得先把加法、乘法构造出来。 　　先考虑二元集合R = \\{0, 1\\}构成的交换环(R, +, \\times)，不妨设加法单位元是0，由交换律可知 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1 \\end{align*} 若1 + 1 = 1，则1没有逆元，故1 + 1 = 0，不难验证这样定义的(R, +)构成交换群。由于\\times对+满足分配律，因此 \\begin{align*} 0 \\times 0 = (0 + 0) \\times 0 = 0 \\times 0 + 0 \\times 0 & \\Longrightarrow 0 \\times 0 = 0 \\\\ 0 \\times 1 = (0 + 0) \\times 1 = 0 \\times 1 + 0 \\times 1 & \\Longrightarrow 0 \\times 1 = 0 \\\\ 1 \\times 0 = 1 \\times (0 + 0) = 1 \\times 0 + 1 \\times 0 & \\Longrightarrow 1 \\times 0 = 0 \\end{align*} 最后1 \\times 1无论等于0还是1，(R, \\times)均可构成半群。因此二元集合可构成两种环，加法均为 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1, \\quad 1 + 1 = 0 \\\\ \\end{align*} 乘法分别为 \\begin{align*} 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 0 \\\\ 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 1 \\end{align*} 即只在1 \\times 1的结果上有区别。若加法单位元是1，上述所有运算结果的0和1互换位置，整体结构不变。 　　设R^\\Omega = \\{ f: \\Omega \\mapsto R \\}，由R的特性知每个f都是将\\Omega中的一部分元素映射为0，剩下映射为1，因此R^\\Omega中共有|\\Pcal(\\Omega)|个元素，每个元素均是\\Omega某个子集的特征函数： \\begin{align*} R^\\Omega = \\{ 1_X \\mid X \\in \\Pcal(\\Omega) \\} \\end{align*} 这样就在R^\\Omega和\\Pcal(\\Omega)间建立了一一对应，即g: 1_X \\mapsto X是一个双射。若R^\\Omega想构成环，其上的加法、乘法只能由R上的加法、乘法导出： \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) \\triangleq 1_X(a) + 1_Y(a) \\\\ \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) \\triangleq 1_X(a) \\times 1_Y(a) \\end{align*} 　　根据R上的加法规则有 \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) = \\begin{cases} 0 + 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 + 0 = 1 & \\forall a \\in X \\setminus Y \\\\ 0 + 1 = 1 & \\forall a \\in Y \\setminus X \\\\ 1 + 1 = 0 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 即R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{X \\Delta Y} \\end{align*} 两个集合的特征函数的加和等于其对称差的特征函数。R上的乘法规则不唯一 \\begin{align*} \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) = \\begin{cases} 0 \\times 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 \\times 0 = 0 & \\forall a \\in X \\setminus Y \\\\ 0 \\times 1 = 0 & \\forall a \\in Y \\setminus X \\\\ 1 \\times 1 = 0~\\text{或}~1 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 前者对应任何两个集合的特征函数的乘积都是空集的特征函数，后者对应乘积是交集的特征函数： \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\emptyset ~\\text{或}~ 1_{X \\cap Y} \\end{align*} 　　若R上的加法单位元是1，运算规则中的0和1互换位置，因此导出的R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)} \\end{align*} 同样乘法规则不唯一，其中一个对应任何两个集合的乘积都是全集的特征函数，另一个对应乘积是交集的补集的特征函数，即 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\Omega ~\\text{或}~ 1_{\\complement (X \\cap Y)} \\end{align*} 即在前者的基础上多个取补集的操作(空集的补集是全集)。 　　至此给出了R^\\Omega可能构成的四种交换环 \\begin{align*} & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_\\emptyset) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_{X \\cap Y}) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_\\Omega) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_{\\complement (X \\cap Y)}) \\end{align*} 注意对于第二种交换环有 \\begin{align*} g(1_X \\oplus 1_Y) & = g(1_{X \\Delta Y}) = X \\Delta Y = g(1_X) \\Delta g(1_Y) \\\\ g(1_X \\otimes 1_Y) & = g(1_{X \\cap Y}) = X \\cap Y = g(1_X) \\cap g(1_Y) \\end{align*} 即(\\Pcal(\\Omega), \\Delta, \\cap)同构于(R^\\Omega, \\oplus, \\otimes)，也构成交换环，其他情形没有如此简洁的对应(常用的二元集合运算没有结果恒为空集、全集或两者对称差、交集的补集，除非重新定义)。 　　对\\forall \\Acal \\subseteq \\Pcal(\\Omega)，若其能够构成代数环，则(\\Acal, \\Delta, \\cap)应为(\\Pcal(\\Omega), \\Delta, \\cap)的子环，即\\Acal对\\Delta、\\cap保持封闭，于是对\\forall X, Y \\in \\Acal有 \\begin{align*} \\emptyset & = X \\Delta X \\in \\Acal \\\\ X \\setminus Y & = (X \\Delta Y) \\cap X \\in \\Acal \\\\ X \\cup Y & = (X \\Delta Y) \\Delta (X \\cap Y) \\in \\Acal \\end{align*} 因此\\Acal是集合环。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-08-18 22:18:15 "},"posts/measure/interval.html":{"url":"posts/measure/interval.html","title":"区间","keywords":"","body":"　　Lebesgue积分的核心问题是给\\Rbb的子集赋予“长度”，而\\Rbb上最简单的子集就是区间，故从区间入手不失为一种途径。 　　区间是拥有凸性的一类子集，共有10种： \\begin{align*} (a,b), \\quad [a,b), \\quad (a,b], \\quad [a,b], \\quad (a,\\infty), \\quad [a,\\infty), \\quad (-\\infty,a), \\quad (-\\infty,a], \\quad (-\\infty, \\infty), \\quad \\emptyset \\end{align*} 其中\\Rbb = (-\\infty, \\infty)就是全集，\\emptyset是其补集，此外[a,a] = \\{ a \\}，因此单点集也属于区间。 　　对任意两个区间I_1、I_2，其交集是一个区间(\\emptyset也是区间)；其并集要么是一个区间，要么存在t满足如下两种情况之一：(1).对\\forall x_1 \\in I_1、\\forall x_2 \\in I_2有x_1 ；(2).对\\forall x_1 \\in I_1、\\forall x_2 \\in I_2有x_2 ；其补集要么是一个区间，要么是两个区间的并集。 　　下面考虑所有由区间的有限并(finite union)构成的集合\\Ical，不难验证\\Ical是一个代数。首先全集\\Rbb = (-\\infty, \\infty) \\in \\Ical；设E_1 = \\cup_{j \\in [n]} I_j \\in \\Ical，E_2 = \\cup_{k \\in [n']} I'_k \\in \\Ical，那么E_1 \\cup E_2显然还是区间的有限并；又 \\begin{align*} E_1 \\cap E_2 = (\\cup_{j \\in [n]} I_j) \\cap (\\cup_{k \\in [n']} I'_k) = \\cup_{j \\in [n]} \\cup_{k \\in [n']} (I_j \\cap I'_k) \\end{align*} 由于I_j \\cap I'_k是一个区间，因此E_1 \\cap E_2也是区间的有限并，从而属于\\Ical，最后由De Morgan律知\\complement E_1 = \\cap_{j \\in [n]} \\complement I_j，而每个\\complement I_j均是区间的有限并，因此其交集也属于\\Ical，故\\Ical是一个代数。 　　对于\\Ical中任一元素E，将能合并成一个区间的都合并掉，则可得到标准形式 \\begin{align*} E = I_1 \\cup \\cdots \\cup I_n \\end{align*} 其中I_1, \\ldots, I_n两两交集为空，且存在t_1, \\ldots, t_{n-1}满足 \\begin{align*} x_1 \\Ical中的任一写成该形式的集合默认为其标准形式。 　　下面考虑给区间赋予长度，直觉上来说区间长度就是其端点的差值，无界区间长度为\\infty，不相交区间的并的长度是它们的长度之和，故引入长度函数m: \\Ical \\mapsto [0, \\infty]： \\begin{align*} & m((a,b)) = m([a,b)) = m((a,b]) = m([a,b]) = b - a, \\quad m(\\emptyset) = 0 \\\\ & m((a,\\infty)) = m([a,\\infty)) = m((-\\infty,a)) = m((-\\infty,a]) = m((-\\infty, \\infty)) = \\infty \\end{align*} 对任意E = I_1 \\cup \\cdots \\cup I_n \\in \\Ical，定义m(E) = \\sum_{j \\in [n]} m(I_j)。 　　上述定义的长度函数m: \\Ical \\mapsto [0, \\infty]满足 有限可加性：设E_1, E_2, \\ldots, E_n \\in \\Ical且两两不相交，则m(\\cup_{j \\in [n]} E_j) = \\sum_{j \\in [n]} m(E_j)； 单调性：设E_1, E_2 \\in \\Ical且E_1 \\subseteq E_2，则m(E_1) \\leq m(E_2)； 有限次可加性：设E_1, E_2, \\ldots \\in \\Ical，则m(\\cup_{j \\in [n]} E_j) \\leq \\sum_{j \\in [n]} m(E_j)； 可数可加性：设E_1, E_2, \\ldots \\in \\Ical且两两不相交，若\\cup_{j=1}^\\infty E_j \\in \\Ical，则m(\\cup_{j=1}^\\infty E_j) = \\sum_{j=1}^\\infty m(E_j)； 可数次可加性：设E_1, E_2, \\ldots \\in \\Ical，若\\cup_{j=1}^\\infty E_j \\in \\Ical，则m(\\cup_{j=1}^\\infty E_j) \\leq \\sum_{j=1}^\\infty m(E_j)； 平移不变性：对\\forall E \\in \\Ical和x_0 \\in \\Rbb，E + x_0 \\triangleq \\{ x + x_0 \\mid x \\in E \\} \\in \\Ical且m(E + x_0) = m(E)。 　　可数可加性、可数次可加性分别是有限可加性、有限次可加性的推广，令E_{n+1} = E_{n+2} = \\cdots = \\emptyset即可由前者导出后者。此外可数(次)可加性的前提是\\cup_{j=1}^\\infty E_j \\in \\Ical，否则m(\\cup_{j=1}^\\infty E_j)没有定义，但这并不要求\\Ical是一个\\sigma-代数。 证明： 只需证明两个集合的情况即可由数学归纳法知结论对任意自然数n都成立。设E_1 \\cup E_2 = \\cup_{j \\in [n']} I_j，则m(E_1 \\cup E_2) = \\sum_{j \\in [n']} m(I_j)。注意构成E_1的每个区间必然都属于某个I_j，故其标准形式为E_1 = \\cup_{j \\in [n']} (E_1 \\cap I_j)，即m(E_1) = \\sum_{j \\in [n']} m(E_1 \\cap I_j)，同理m(E_2) = \\sum_{j \\in [n']} m(E_2 \\cap I_j)，于是待证结论变成 \\begin{align*} \\sum_{j \\in [n']} m(I_j) = \\sum_{j \\in [n']} m(E_1 \\cap I_j) + \\sum_{j \\in [n']} m(E_2 \\cap I_j) \\end{align*} 即只需证m(I_j) = m(E_1 \\cap I_j) + m(E_2 \\cap I_j)。注意E_1 \\cap I_j、E_2 \\cap I_j不相交，因此其标准形式中的所有区间均两两不相交，又这些区间的并集是区间I_j，因此这些区间写成标准形式是首尾相连的(前一个区间的右端点等于后一个区间的左端点)，从而m(I_j) = m(E_1 \\cap I_j) + m(E_2 \\cap I_j)。 若E_1 \\subseteq E_2，则E_2 = E_1 \\cup (E_2 \\setminus E_1)且E_1 \\cap (E_2 \\setminus E_1) = \\emptyset，由有限可加性和长度函数的非负性知 \\begin{align*} m(E_2) = m(E_1) + m(E_2 \\setminus E_1) \\geq m(E_1) \\end{align*} 只需证明两个集合的情况即可由数学归纳法知结论对任意自然数n都成立。由于E_1 \\cup E_2 = E_1 \\cup (E_2 \\setminus E_1)且E_1 \\cap (E_2 \\setminus E_1) = \\emptyset，又(E_2 \\setminus E_1) \\subseteq E_2，由有限可加性和单调性知 \\begin{align*} m(E_1 \\cup E_2) = m(E_1) + m(E_2 \\setminus E_1) \\leq m(E_1) + m(E_2) \\end{align*} 由有限可加性的证明知只需考虑\\cup_{j=1}^\\infty E_j等于一个区间I的情况，设E_j = \\cup_{k \\in [n_j]} I_{j,k}，于是 \\begin{align*} I = E_1 \\cup E_2 \\cup \\cdots = I_{1,1} \\cup I_{1,2} \\cup \\cdots \\cup I_{1,n_1} \\cup I_{2,1} \\cup I_{2,2} \\cup \\cdots \\cup I_{2,n_2} \\cup I_{3,1} \\cup \\cdots \\end{align*} 由于E_1, E_2, \\ldots两两不相交，因此上式中的可数无穷项I_{j,k}均两两不相交，将其写成标准形式： \\begin{align*} I = I_1 \\cup I_2 \\cup \\cdots = \\cup_{k=1}^\\infty I_k \\end{align*} 注意m(E_j) = \\sum_{k \\in [n_j]} m(I_{j,k})，于是待证结论变成 \\begin{align*} m(I) = m(\\cup_{k=1}^\\infty I_k) = \\sum_{k=1}^\\infty m(I_k) \\end{align*} 对任意自然数n，由有限可加性和单调性知 \\begin{align*} \\sum_{k \\in [n]} m(I_k) = m(\\cup_{k \\in [n]} I_k) \\leq m(\\cup_{k=1}^\\infty I_k) = m(I) \\end{align*} 令n \\rightarrow \\infty可得\\sum_{k=1}^\\infty m(I_k) \\leq m(I)。 下面证明另一个方向，不妨设所有的I_k都是有界区间(否则若某个I_k无界，则I也无界，上式两边都是\\infty)，则对\\forall \\epsilon > 0，存在开区间J_k从外部充分逼近I_k，即I_k \\subseteq J_k且m(J_k) 。引入有界闭区间[a_0, b_0] \\subseteq I，于是 \\begin{align*} [a\\_0, b\\_0] \\subseteq I = \\cup\\_{k=1}^\\infty I\\_k \\subseteq \\cup\\_{k=1}^\\infty J\\_k \\end{align*} 即J_1, J_2, \\ldots是有界闭区间[a_0, b_0]的一个开覆盖(open cover)，由Heine-Borel定理知其存在有限子覆盖，不妨设子覆盖的下标集合是\\Ical'，于是由有限可加性和单调性知 \\begin{align*} a\\_0 - b\\_0 = m([a\\_0, b\\_0]) \\leq \\sum\\_{k \\in \\Ical'} m(J\\_k) \\end{align*} 若I无界，可以选取[a_0, b_0]使得b_0 - a_0任意的大，而\\epsilon又可以任意的小，于是有\\sum_{k=1}^\\infty m(I_k) = \\infty = m(I)；若I有界，选取[a_0, b_0]从内部充分逼近I，即使得b_0 - a_0 > m(I) - \\epsilon，于是有 \\begin{align*} m(I) - \\epsilon \\end{align*} 由于\\epsilon可以任意的小，故m(I) \\leq \\sum_{k=1}^\\infty m(I_k)。 综上有m(\\cup_{k=1}^\\infty I_k) = m(I) = \\sum_{k=1}^\\infty m(I_k)。 令F_j = E_j \\setminus (\\cup_{k \\in [j-1]} E_k) \\subseteq E_j，易知F_1, F_2, \\ldots两两不相交且对任意自然数n有\\cup_{j \\in [n]} F_j = \\cup_{j \\in [n]} E_j，于是 \\begin{align*} m(\\cup_{j \\in [n]} E_j) = m(\\cup_{j \\in [n]} F_j) = \\sum_{j \\in [n]} m(F_j) \\leq \\sum_{j \\in [n]} m(E_j) \\end{align*} 令n \\rightarrow \\infty可知m(\\cup_{j=1}^\\infty E_j) \\leq \\sum_{j=1}^\\infty m(E_j)。 设E = \\cup_{j=1}^\\infty I_j，则E + x_0 = \\cup_{j=1}^\\infty (I_j + x_0)。若I_j有界，设其端点分别为a、b，则I_j + x_0依然有界且端点分别为a + x_0、b + x_0，于是m(I_j + x_0) = (b + x_0) - (a + x_0) = b - a = m(I_j)；若I_j无界，则I_j + x_0也无界(\\pm \\infty + x_0 = \\pm \\infty)，且m(I_j + x_0) = \\infty = m(I_j)，综上有m(E + x_0) = m(E)。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-08-19 22:23:18 "}}