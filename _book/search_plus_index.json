{"./":{"url":"./","title":"简介","keywords":"","body":"数学笔记 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-03 17:17:39 "},"posts/matrix/derivative.html":{"url":"posts/matrix/derivative.html","title":"导数","keywords":"","body":"　　标量、向量、矩阵间的求导共有9种可能，其中\\color{green}{\\partial 标量 / \\partial 标量}就是我们熟悉的单变量微积分，\\color{red}{\\partial 向量 / \\partial 矩阵}、\\color{red}{\\partial 矩阵 / \\partial 向量}、\\color{red}{\\partial 矩阵 / \\partial 矩阵}会涉及高阶张量，处理更为麻烦，因此本文只考虑剩下的5种情形。 　　设\\uv \\in \\Rbb^l，\\Uv \\in \\Rbb^{m \\times n}，则向量、矩阵对标量求导的定义为 \\begin{align*} \\frac{\\partial \\uv}{\\partial x} \\triangleq \\begin{bmatrix} \\frac{\\partial u_1}{\\partial x} \\\\ \\frac{\\partial u_2}{\\partial x} \\\\ \\vdots \\\\ \\frac{\\partial u_l}{\\partial x} \\end{bmatrix}, \\quad \\frac{\\partial \\Uv}{\\partial x} \\triangleq \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} & \\frac{\\partial u_{12}}{\\partial x} & \\ldots & \\frac{\\partial u_{1n}}{\\partial x} \\\\ \\frac{\\partial u_{21}}{\\partial x} & \\frac{\\partial u_{22}}{\\partial x} & \\ldots & \\frac{\\partial u_{2n}}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} & \\frac{\\partial u_{m2}}{\\partial x} & \\ldots & \\frac{\\partial u_{mn}}{\\partial x} \\end{bmatrix} \\end{align*} 设\\xv \\in \\Rbb^l，\\Xv \\in \\Rbb^{m \\times n}，则标量对向量、矩阵求导的定义为 \\begin{align*} \\frac{\\partial u}{\\partial \\xv} \\triangleq \\begin{bmatrix} \\frac{\\partial u}{\\partial x_1} & \\frac{\\partial u}{\\partial x_2} & \\ldots & \\frac{\\partial u}{\\partial x_l} \\end{bmatrix}, \\quad \\frac{\\partial u}{\\partial \\Xv} \\triangleq \\begin{bmatrix} \\frac{\\partial u}{\\partial x_{11}} & \\frac{\\partial u}{\\partial x_{21}} & \\ldots & \\frac{\\partial u}{\\partial x_{m1}} \\\\ \\frac{\\partial u}{\\partial x_{12}} & \\frac{\\partial u}{\\partial x_{22}} & \\ldots & \\frac{\\partial u}{\\partial x_{m2}} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u}{\\partial x_{1n}} & \\frac{\\partial u}{\\partial x_{2n}} & \\ldots & \\frac{\\partial u}{\\partial x_{mn}} \\end{bmatrix} \\end{align*} 即向量、矩阵对标量求导的结果与分子尺寸相同，标量对向量、矩阵求导的结果与分母的转置尺寸相同。向量对向量求导的定义为Jacobian矩阵： \\begin{align*} \\frac{\\partial \\uv}{\\partial \\xv} \\triangleq \\begin{bmatrix} \\frac{\\partial u_1}{\\partial x_1} & \\frac{\\partial u_1}{\\partial x_2} & \\ldots & \\frac{\\partial u_1}{\\partial x_l} \\\\ \\frac{\\partial u_2}{\\partial x_1} & \\frac{\\partial u_2}{\\partial x_2} & \\ldots & \\frac{\\partial u_2}{\\partial x_l} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_l}{\\partial x_1} & \\frac{\\partial u_l}{\\partial x_2} & \\ldots & \\frac{\\partial u_l}{\\partial x_l} \\end{bmatrix} \\end{align*} 即行数与分子尺寸相同、列数与分母尺寸相同。 　　以上即为分子布局，其好处是链式法则跟单变量微积分中的顺序一样，坏处是计算标量值函数f(\\xv)关于向量变量\\xv的梯度时要多做一个转置：\\nabla f = (\\frac{\\partial f}{\\partial \\xv})^\\top，因为我们更习惯梯度是列向量。分母布局的结果均是分子布局的转置，好处就是算梯度时不用做转置，坏处就是链式法则的顺序要完全反过来。 基本结果 　　以下结果根据定义和单变量微积分的求导法则都是显然的。 　　单变量微积分中常量的导数为零 \\begin{align*} \\frac{\\partial a}{\\partial x} = 0 \\end{align*} 类似的这里有 \\begin{align*} \\frac{\\partial \\av}{\\partial x} = \\zerov, \\quad \\frac{\\partial a}{\\partial \\xv} = \\zerov^\\top, \\quad \\frac{\\partial \\av}{\\partial \\xv} = \\zerov, \\quad \\frac{\\partial \\Av}{\\partial x} = \\zerov, \\quad \\frac{\\partial a}{\\partial \\Xv} = \\zerov^\\top \\end{align*} 　　单变量微积分中常数标量乘的求导法则为 \\begin{align*} \\frac{\\partial a u}{\\partial x} = a \\frac{\\partial u}{\\partial x} \\end{align*} 类似的这里有 \\begin{align*} \\frac{\\partial a \\uv}{\\partial x} = a \\frac{\\partial \\uv}{\\partial x}, \\quad \\frac{\\partial a u}{\\partial \\xv} = a \\frac{\\partial u}{\\partial \\xv}, \\quad \\frac{\\partial a \\uv}{\\partial \\xv} = a \\frac{\\partial \\uv}{\\partial \\xv}, \\quad \\frac{\\partial a \\Uv}{\\partial x} = a \\frac{\\partial \\Uv}{\\partial x}, \\quad \\frac{\\partial a u}{\\partial \\Xv} = a \\frac{\\partial u}{\\partial \\Xv} \\end{align*} 　　单变量微积分中加法的求导法则为 \\begin{align*} \\frac{\\partial (u+v)}{\\partial x} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial x} \\end{align*} 类似的这里有 \\begin{align*} & \\frac{\\partial (\\uv + \\vv)}{\\partial x} = \\frac{\\partial \\uv}{\\partial x} + \\frac{\\partial \\vv}{\\partial x}, \\quad \\frac{\\partial (u+v)}{\\partial \\xv} = \\frac{\\partial u}{\\partial \\xv} + \\frac{\\partial v}{\\partial \\xv}, \\quad \\frac{\\partial (\\uv + \\vv)}{\\partial \\xv} = \\frac{\\partial \\uv}{\\partial \\xv} + \\frac{\\partial \\vv}{\\partial \\xv} \\\\ & \\frac{\\partial (\\Uv + \\Vv)}{\\partial x} = \\frac{\\partial \\Uv}{\\partial x} + \\frac{\\partial \\Vv}{\\partial x}, \\quad \\frac{\\partial (u + v)}{\\partial \\Xv} = \\frac{\\partial u}{\\partial \\Xv} + \\frac{\\partial v}{\\partial \\Xv} \\end{align*} 　　单变量微积分中乘法的求导法则为 \\begin{align*} \\frac{\\partial uv}{\\partial x} = \\frac{\\partial u}{\\partial x} v + u \\frac{\\partial v}{\\partial x} \\end{align*} 类似的这里有 \\begin{align*} & \\frac{\\partial \\uv \\vv}{\\partial x} = \\frac{\\partial \\uv}{\\partial x} \\vv + \\uv \\frac{\\partial \\vv}{\\partial x}, \\quad \\frac{\\partial uv}{\\partial \\xv} = \\frac{\\partial u}{\\partial \\xv} v + u \\frac{\\partial v}{\\partial \\xv} \\\\ & \\frac{\\partial \\Uv \\Vv}{\\partial x} = \\frac{\\partial \\Uv}{\\partial x} \\Vv + \\Uv \\frac{\\partial \\Vv}{\\partial x}, \\quad \\frac{\\partial uv}{\\partial \\Xv} = \\frac{\\partial u}{\\partial \\Xv} v + u \\frac{\\partial v}{\\partial \\Xv} \\end{align*} 其中第二行是因为 \\begin{align*} \\left[ \\frac{\\partial \\Uv \\Vv}{\\partial x} \\right]_{ij} & = \\frac{\\partial \\sum_k u_{ik} v_{kj}}{\\partial x} = \\sum_k \\frac{\\partial u_{ik}}{\\partial x} v_{kj} + \\sum_k u_{ik} \\frac{\\partial v_{kj}}{\\partial x} = \\left[ \\frac{\\partial \\Uv}{\\partial x} \\Vv \\right]_{ij} + \\left[ \\Uv \\frac{\\partial \\Vv}{\\partial x} \\right]_{ij} \\\\ \\left[ \\frac{\\partial uv}{\\partial \\Xv} \\right]_{ij} & = \\frac{\\partial uv}{\\partial x_{ji}} = \\frac{\\partial u}{\\partial x_{ji}} v + u \\frac{\\partial v}{\\partial x_{ji}} = \\left[ \\frac{\\partial u}{\\partial \\Xv} \\right]_{ij} v + u \\left[ \\frac{\\partial v}{\\partial \\Xv} \\right]_{ij} \\end{align*} 第一行可看作第二行的特例。\\partial \\uv \\vv / \\partial \\xv有两种可能，一是\\uv \\vv为标量，即两者的内积，这里暂且不表，后文再讲；二是\\uv \\vv为矩阵，这属于我们不考虑的\\partial 矩阵 / \\partial 向量情形。 　　单变量微积分中有\\partial x / \\partial x = 1，类似的这里有 \\begin{align*} \\frac{\\partial x_i}{\\partial \\xv} = \\ev_i^\\top, \\quad \\frac{\\partial \\xv}{\\partial x_i} = \\ev_i, \\quad \\frac{\\partial \\xv}{\\partial \\xv} = \\Iv, \\quad \\frac{\\partial x_{ij}}{\\partial \\Xv} = \\Ev_{ji}, \\quad \\frac{\\partial \\Xv}{\\partial x_{ij}} = \\Ev_{ij} \\end{align*} 其中\\Ev_{ij}是(i,j)处为1其余为0的矩阵。 　　单变量微积分中的链式法则为 \\begin{align*} \\frac{\\partial g(u)}{\\partial x} = \\frac{\\partial g(u)}{\\partial u} \\frac{\\partial u}{\\partial x} \\end{align*} 类似的， 只涉及向量：设\\xv \\in \\Rbb^n，\\uv = \\uv(\\xv) \\in \\Rbb^m，\\gv: \\Rbb^m \\mapsto \\Rbb^l，则 \\begin{align*} \\underbrace{\\frac{\\partial \\gv(\\uv)}{\\partial \\xv}}_{l \\times n} = \\underbrace{\\frac{\\partial \\gv(\\uv)}{\\partial \\uv}}_{l \\times m} \\underbrace{\\frac{\\partial \\uv}{\\partial \\xv}}_{m \\times n} \\end{align*} 这是因为 \\begin{align*} \\left[ \\frac{\\partial \\gv(\\uv)}{\\partial \\xv} \\right]_{ij} & = \\frac{\\partial [\\gv(\\uv)]_i}{\\partial x_j} = \\sum_{k \\in [m]} \\frac{\\partial [\\gv(\\uv)]_i}{\\partial u_k} \\frac{\\partial u_k}{\\partial x_j} = \\frac{\\partial [\\gv(\\uv)]_i}{\\partial \\uv} \\frac{\\partial \\uv}{\\partial x_j} \\\\ & = \\left[ \\frac{\\partial \\gv(\\uv)}{\\partial \\uv} \\right]_{i,:} \\left[ \\frac{\\partial \\uv}{\\partial \\xv} \\right]_{:,j} = \\left[ \\frac{\\partial \\gv(\\uv)}{\\partial \\uv} \\frac{\\partial \\uv}{\\partial \\xv} \\right]_{i,j} \\end{align*} 注意若n = m = l = 1，就退化成了单变量的链式法则。 自变量是矩阵：设u = u(\\Xv)，g: \\Rbb \\mapsto \\Rbb，则 \\begin{align*} \\frac{\\partial g(u)}{\\partial \\Xv} = \\frac{\\partial g(u)}{\\partial u} \\frac{\\partial u}{\\partial \\Xv} \\end{align*} 这是因为 \\begin{align*} \\left[ \\frac{\\partial g(u)}{\\partial \\Xv} \\right]_{ij} & = \\frac{\\partial g(u)}{\\partial x_{ji}} = \\frac{\\partial g(u)}{\\partial u} \\frac{\\partial u}{\\partial x_{ji}} = \\frac{\\partial g(u)}{\\partial u} \\left[ \\frac{\\partial u}{\\partial \\Xv} \\right]_{ij} \\end{align*} 中间变量是矩阵：设\\Uv = \\Uv(x) \\in \\Rbb^{m \\times n}，g: \\Rbb^{m \\times n} \\mapsto \\Rbb，则 \\begin{align} \\label{eq: chain-matrix} \\class{blue}{\\frac{\\partial g(\\Uv)}{\\partial x}} = \\sum_p \\sum_q \\frac{\\partial g(\\Uv)}{\\partial u_{pq}} \\frac{\\partial u_{pq}}{\\partial x} = \\sum_q \\sum_p \\left[ \\frac{\\partial g(\\Uv)}{\\partial \\Uv} \\right]_{qp} \\left[ \\frac{\\partial \\Uv}{\\partial x} \\right]_{pq} = \\class{blue}{\\tr \\left( \\frac{\\partial g(\\Uv)}{\\partial \\Uv} \\frac{\\partial \\Uv}{\\partial x} \\right)} \\end{align} 向量对标量求导 　　矩阵和向量的乘积是向量，若\\Av与\\xv无关，易知有 \\begin{align*} & \\left[ \\frac{\\partial \\Av \\uv}{\\partial x} \\right]_{i} = \\frac{\\partial [\\Av \\uv]_i}{\\partial x} = \\frac{\\partial \\sum_k a_{ik} u_k}{\\partial x} = \\sum_k a_{ik} \\frac{\\partial u_k}{\\partial x} = \\left[ \\Av \\frac{\\partial \\uv}{\\partial x} \\right]_i \\Longrightarrow \\class{blue}{\\frac{\\partial \\Av \\uv}{\\partial x} = \\Av \\frac{\\partial \\uv}{\\partial x}} \\\\ & \\left[ \\frac{\\partial \\uv^\\top \\Av}{\\partial x} \\right]_i = \\frac{\\partial [\\uv^\\top \\Av]_i}{\\partial x} = \\frac{\\partial [\\Av^\\top \\uv]_i}{\\partial x} = \\left[ \\Av^\\top \\frac{\\partial \\uv}{\\partial x} \\right]_i \\Longrightarrow \\class{blue}{\\frac{\\partial \\uv^\\top \\Av}{\\partial x} = \\Av^\\top \\frac{\\partial \\uv}{\\partial x}} \\end{align*} 　　向量的外积也是向量，记\\uv = [u_1(x); u_2(x); u_3(x)]，\\vv = [v_1(x); v_2(x); v_3(x)]，则 \\begin{align*} \\uv^\\top \\times \\vv = \\begin{bmatrix} u_2 v_3 - u_3 v_2 \\\\ u_3 v_1 - u_1 v_3 \\\\ u_1 v_2 - u_2 v_1 \\end{bmatrix} \\end{align*} 于是 \\begin{align*} \\class{blue}{\\frac{\\partial (\\uv^\\top \\times \\vv)}{\\partial x}} & = \\begin{bmatrix} \\frac{\\partial u_2}{\\partial x} v_3 - \\frac{\\partial u_3}{\\partial x} v_2 + u_2 \\frac{\\partial v_3}{\\partial x} - u_3 \\frac{\\partial v_2}{\\partial x} \\\\ \\frac{\\partial u_3}{\\partial x} v_1 - \\frac{\\partial u_1}{\\partial x} v_3 + u_3 \\frac{\\partial v_1}{\\partial x} - u_1 \\frac{\\partial v_3}{\\partial x} \\\\ \\frac{\\partial u_1}{\\partial x} v_2 - \\frac{\\partial u_2}{\\partial x} v_1 + u_1 \\frac{\\partial v_2}{\\partial x} - u_2 \\frac{\\partial v_1}{\\partial x} \\\\ \\end{bmatrix} = \\class{blue}{\\left( \\frac{\\partial \\uv}{\\partial x} \\right)^\\top \\times \\vv + \\uv^\\top \\times \\frac{\\partial \\vv}{\\partial x}} \\end{align*} 标量对向量求导 　　二次型是标量，设\\Av与\\xv无关，易知有 \\begin{align*} \\left[ \\frac{\\partial \\uv^\\top \\Av \\vv}{\\partial \\xv} \\right]_i & = \\frac{\\partial \\uv^\\top \\Av \\vv}{\\partial x_i} = \\frac{\\partial \\sum_j \\sum_k u_j a_{jk} v_k}{\\partial x_i} = \\sum_j \\sum_k u_j a_{jk} \\frac{\\partial v_k}{\\partial x_i} + \\sum_j \\sum_k \\frac{\\partial u_j}{\\partial x_i} a_{jk} v_k \\\\ & = \\uv^\\top \\Av \\frac{\\partial \\vv}{\\partial x_i} + \\vv^\\top \\Av^\\top \\frac{\\partial \\uv}{\\partial x_i} = \\left[ \\uv^\\top \\Av \\frac{\\partial \\vv}{\\partial \\xv} \\right]_i + \\left[ \\vv^\\top \\Av^\\top \\frac{\\partial \\uv}{\\partial \\xv} \\right]_i \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial \\uv^\\top \\Av \\vv}{\\partial \\xv} = \\uv^\\top \\Av \\frac{\\partial \\vv}{\\partial \\xv} + \\vv^\\top \\Av^\\top \\frac{\\partial \\uv}{\\partial \\xv}} \\end{align*} 　　特别的， 取\\Av = \\Iv，则 \\begin{align*} \\frac{\\partial \\uv^\\top \\vv}{\\partial \\xv} = \\uv^\\top \\frac{\\partial \\vv}{\\partial \\xv} + \\vv^\\top \\frac{\\partial \\uv}{\\partial \\xv} \\end{align*} 进一步若\\uv = \\av与\\xv无关，则 \\begin{align*} \\frac{\\partial \\av^\\top \\vv}{\\partial \\xv} = \\av^\\top \\frac{\\partial \\vv}{\\partial \\xv}, \\quad \\frac{\\partial \\av^\\top \\xv}{\\partial \\xv} = \\av^\\top \\frac{\\partial \\xv}{\\partial \\xv} = \\av^\\top, \\quad \\frac{\\partial \\bv^\\top \\Av \\xv}{\\partial \\xv} = \\bv^\\top \\Av \\end{align*} 取\\uv = \\vv = \\xv，则 \\begin{align*} \\frac{\\partial \\xv^\\top \\Av \\xv}{\\partial \\xv} = \\xv^\\top \\Av \\frac{\\partial \\xv}{\\partial \\xv} + \\xv^\\top \\Av^\\top \\frac{\\partial \\xv}{\\partial \\xv} = \\xv^\\top (\\Av + \\Av^\\top) \\overset{\\text{若}\\Av\\text{对称}}{=} 2 \\xv^\\top \\Av \\end{align*} 进一步若\\Av = \\Iv，则 \\begin{align*} \\frac{\\partial \\xv^\\top \\xv}{\\partial \\xv} = \\frac{\\partial \\|\\xv\\|^2}{\\partial \\xv} = 2 \\xv^\\top \\end{align*} 若\\Av = \\bv \\av^\\top，则 \\begin{align*} \\frac{\\partial \\xv^\\top \\bv \\av^\\top \\xv}{\\partial \\xv} = \\frac{\\partial \\av^\\top \\xv \\xv^\\top \\bv}{\\partial \\xv} = \\xv^\\top (\\av \\bv^\\top + \\bv \\av^\\top) \\end{align*} 更一般的有 \\begin{align*} \\frac{\\partial (\\Av \\xv + \\bv)^\\top \\Cv (\\Dv \\xv + \\ev)}{\\partial \\xv} & = \\frac{\\partial (\\xv^\\top \\Av^\\top \\Cv \\Dv \\xv + \\bv^\\top \\Cv \\Dv \\xv + \\xv^\\top \\Av^\\top \\Cv \\ev + \\bv^\\top \\ev)}{\\partial \\xv} \\\\ & = \\xv^\\top (\\Av^\\top \\Cv \\Dv + \\Dv^\\top \\Cv^\\top \\Av) + \\bv^\\top \\Cv \\Dv + \\ev^\\top \\Cv^\\top \\Av \\\\ & = (\\Dv \\xv + \\ev)^\\top \\Cv^\\top \\Av + (\\Av \\xv + \\bv)^\\top \\Cv \\Dv \\end{align*} 　　范数也是标量，若\\av与\\xv无关，则 \\begin{align} \\label{eq: norm} \\left[ \\frac{\\partial \\| \\xv - \\av \\|}{\\partial \\xv} \\right]_i & = \\frac{\\partial \\| \\xv - \\av \\|}{\\partial x_i} = \\frac{\\partial \\sqrt{\\sum_j (x_j - a_j)^2}}{\\partial x_i} = \\frac{1}{2} \\frac{2 (x_i - a_i)}{\\sqrt{\\sum_j (x_j - a_j)^2}} = \\frac{x_i - a_i}{\\| \\xv - \\av \\|} \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial \\| \\xv - \\av \\|}{\\partial \\xv} = \\frac{(\\xv - \\av)^\\top}{\\| \\xv - \\av \\|}} \\nonumber \\end{align} 向量对向量求导 　　若\\Av与\\xv无关，易知有 \\begin{align*} & \\left[ \\frac{\\partial \\Av \\uv}{\\partial \\xv} \\right]_{ij} = \\frac{\\partial [\\Av \\uv]_i}{\\partial x_j} = \\frac{\\partial \\sum_k a_{ik} u_k}{\\partial x_j} = \\sum_k a_{ik} \\frac{\\partial u_k}{\\partial x_j} = \\left[ \\Av \\frac{\\partial \\uv}{\\partial \\xv} \\right]_{ij} \\Longrightarrow \\class{blue}{\\frac{\\partial \\Av \\uv}{\\partial \\xv} = \\Av \\frac{\\partial \\uv}{\\partial \\xv}} \\\\ & \\left[ \\frac{\\partial \\uv^\\top \\Av}{\\partial \\xv} \\right]_{ij} = \\frac{\\partial [\\uv^\\top \\Av]_i}{\\partial x_j} = \\frac{\\partial [\\Av^\\top \\uv]_i}{\\partial x_j} = \\left[ \\Av^\\top \\frac{\\partial \\uv}{\\partial \\xv} \\right]_{ij} \\Longrightarrow \\class{blue}{\\frac{\\partial \\uv^\\top \\Av}{\\partial \\xv} = \\Av^\\top \\frac{\\partial \\uv}{\\partial \\xv}} \\end{align*} 特别的，若\\uv = \\xv，则 \\begin{align*} \\frac{\\partial \\Av \\xv}{\\partial \\xv} = \\Av \\frac{\\partial \\xv}{\\partial \\xv} = \\Av, \\quad \\frac{\\partial \\xv^\\top \\Av}{\\partial \\xv} = \\Av^\\top \\frac{\\partial \\xv}{\\partial \\xv} = \\Av^\\top \\end{align*} 　　若v = v(\\xv)，则 \\begin{align*} \\left[ \\frac{\\partial v \\uv}{\\partial \\xv} \\right]_{ij} = \\frac{\\partial v u_i}{\\partial x_j} = v \\frac{\\partial u_i}{\\partial x_j} + u_i \\frac{\\partial v}{\\partial x_j} = v \\left[ \\frac{\\partial \\uv}{\\partial \\xv} \\right]_{ij} + \\left[ \\uv \\frac{\\partial v}{\\partial \\xv} \\right]_{ij} \\Longrightarrow \\class{blue}{\\frac{\\partial v \\uv}{\\partial \\xv} = v \\frac{\\partial \\uv}{\\partial \\xv} + \\uv \\frac{\\partial v}{\\partial \\xv}} \\end{align*} 注意第一项是标量乘以Jacobian矩阵，第二项是列向量乘以行向量。 　　若\\av与\\xv无关，结合式(\\ref{eq: norm})可得 \\begin{align*} \\left[ \\frac{\\partial}{\\partial \\xv} \\frac{\\xv - \\av}{\\| \\xv - \\av \\|} \\right]_{ij} & = \\frac{\\partial}{\\partial x_j} \\frac{x_i - a_i}{\\| \\xv - \\av \\|} = \\frac{\\delta_{ij} \\|\\xv - \\av\\|}{\\| \\xv - \\av \\|^2} - \\frac{x_i - a_i}{\\| \\xv - \\av \\|^2} \\frac{\\partial \\| \\xv - \\av \\|}{\\partial x_j} \\\\ & = \\frac{\\delta_{ij}}{\\| \\xv - \\av \\|} - \\frac{x_i - a_i}{\\| \\xv - \\av \\|^2} \\frac{x_j - a_j}{\\| \\xv - \\av \\|} \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial}{\\partial \\xv} \\frac{\\xv - \\av}{\\| \\xv - \\av \\|} = \\frac{\\Iv}{\\| \\xv - \\av \\|} - \\frac{(\\xv - \\av)(\\xv - \\av)^\\top}{\\| \\xv - \\av \\|^3}} \\end{align*} 矩阵对标量求导 　　若u = u(x)，\\Vv = \\Vv(x)，则 \\begin{align*} \\left[ \\frac{\\partial u \\Vv}{\\partial x} \\right]_{ij} = \\frac{\\partial u v_{ij}}{\\partial x} = \\frac{\\partial u}{\\partial x} v_{ij} + u \\frac{\\partial v_{ij}}{\\partial x} = \\frac{\\partial u}{\\partial x} \\left[ \\Vv \\right]_{ij} + u \\left[ \\frac{\\partial \\Vv}{\\partial x} \\right]_{ij} \\Longrightarrow \\class{blue}{\\frac{\\partial u \\Vv}{\\partial x} = \\frac{\\partial u}{\\partial x} \\Vv + u \\frac{\\partial \\Vv}{\\partial x}} \\end{align*} 　　若乘积求导法则中的\\Uv或\\Vv可继续分解为x相关项的乘积，例如\\Vv \\leftarrow \\Vv \\Wv，则 \\begin{align} \\label{eq: product} \\class{blue}{\\frac{\\partial \\Uv \\Vv \\Wv}{\\partial x}} = \\frac{\\partial \\Uv}{\\partial x} \\Vv \\Wv + \\Uv \\frac{\\partial \\Vv \\Wv}{\\partial x} = \\frac{\\partial \\Uv}{\\partial x} \\Vv \\Wv + \\Uv \\left( \\frac{\\partial \\Vv}{\\partial x} \\Wv + \\Vv \\frac{\\partial \\Wv}{\\partial x} \\right) = \\class{blue}{\\frac{\\partial \\Uv}{\\partial x} \\Vv \\Wv + \\Uv \\frac{\\partial \\Vv}{\\partial x} \\Wv + \\Uv \\Vv \\frac{\\partial \\Wv}{\\partial x}} \\end{align} 由此可知若\\Av、\\Bv与x无关，则 \\begin{align*} \\frac{\\partial \\Av \\Uv \\Bv}{\\partial x} = \\Av \\frac{\\partial \\Uv}{\\partial x} \\Bv \\end{align*} 当\\Uv为方阵、n为正整数时有 \\begin{align} \\label{eq: power} \\class{blue}{\\frac{\\partial \\Uv^n}{\\partial x}} = \\Uv^{n-1} \\frac{\\partial \\Uv}{\\partial x} + \\Uv^{n-2} \\frac{\\partial \\Uv}{\\partial x} \\Uv + \\cdots + \\Uv \\frac{\\partial \\Uv}{\\partial x} \\Uv^{n-2} + \\frac{\\partial \\Uv}{\\partial x} \\Uv^{n-1} = \\class{blue}{\\sum_{i \\in [n]} \\Uv^{i-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{n-i}} \\end{align} 　　令乘积求导法则中的\\Vv = \\Uv^{-1}可得 \\begin{align} \\label{eq: inverse} \\zerov = \\frac{\\partial \\Iv}{\\partial x} = \\frac{\\partial \\Uv \\Uv^{-1}}{\\partial x} = \\Uv \\frac{\\partial \\Uv^{-1}}{\\partial x} + \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\Longrightarrow \\class{blue}{\\frac{\\partial \\Uv^{-1}}{\\partial x} = - \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1}} \\end{align} 由此可知 \\begin{align*} \\class{blue}{\\frac{\\partial [\\Xv^{-1}]_{kl}}{\\partial x_{ij}}} & = \\tr \\left( \\frac{\\partial [\\Xv^{-1}]_{kl}}{\\partial \\Xv^{-1}} \\frac{\\partial \\Xv^{-1}}{\\partial x_{ij}} \\right) = - \\tr \\left( \\Ev_{lk} \\Xv^{-1} \\frac{\\partial \\Xv}{\\partial x_{ij}} \\Xv^{-1} \\right) = - \\tr ( \\Xv^{-1} \\Ev_{lk} \\Xv^{-1} \\Ev_{ij} ) \\\\ & = - [\\Xv^{-1} \\Ev_{lk} \\Xv^{-1}]_{ji} = - \\sum_p \\sum_q [\\Xv^{-1}]_{jp} [\\Ev_{lk}]_{pq} [\\Xv^{-1}]_{qi} = \\class{blue}{- [\\Xv^{-1}]_{jl} [\\Xv^{-1}]_{ki}} \\end{align*} 结合式(\\ref{eq: product})还可得Hessian矩阵 \\begin{align*} \\class{blue}{\\frac{\\partial^2 \\Uv^{-1}}{\\partial x \\partial y}} & = \\frac{\\partial}{\\partial y} \\left( - \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\right) = - \\frac{\\partial \\Uv^{-1}}{\\partial y} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} - \\Uv^{-1} \\frac{\\partial^2 \\Uv}{\\partial x \\partial y} \\Uv^{-1} - \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\frac{\\partial \\Uv^{-1}}{\\partial y} \\\\ & = \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial y} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} - \\Uv^{-1} \\frac{\\partial^2 \\Uv}{\\partial x \\partial y} \\Uv^{-1} + \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial y} \\Uv^{-1} \\\\ & = \\class{blue}{\\Uv^{-1} \\left( \\frac{\\partial \\Uv}{\\partial y} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial x} - \\frac{\\partial^2 \\Uv}{\\partial x \\partial y} + \\frac{\\partial \\Uv}{\\partial x} \\Uv^{-1} \\frac{\\partial \\Uv}{\\partial y} \\right) \\Uv^{-1}} \\end{align*} 　　矩阵除了常规的乘积外，还有Kronecker积和Hadamard积。设\\Uv \\in \\Rbb^{m \\times n}，\\Vv \\in \\Rbb^{p \\times q}，则 \\begin{align*} \\class{blue}{\\frac{\\partial \\Uv \\otimes \\Vv}{\\partial x}} & = \\begin{bmatrix} \\frac{\\partial u_{11} \\Vv}{\\partial x} & \\frac{\\partial u_{12} \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{1n} \\Vv}{\\partial x} \\\\ \\frac{\\partial u_{21} \\Vv}{\\partial x} & \\frac{\\partial u_{22} \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{2n} \\Vv}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1} \\Vv}{\\partial x} & \\frac{\\partial u_{m2} \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{mn} \\Vv}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} \\Vv + u_{11} \\frac{\\partial \\Vv}{\\partial x} & \\frac{\\partial u_{12}}{\\partial x} \\Vv + u_{12} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{1n}}{\\partial x} \\Vv + u_{1n} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\frac{\\partial u_{21}}{\\partial x} \\Vv + u_{21} \\frac{\\partial \\Vv}{\\partial x} & \\frac{\\partial u_{22}}{\\partial x} \\Vv + u_{22} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{2n}}{\\partial x} \\Vv + u_{2n} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} \\Vv + u_{m1} \\frac{\\partial \\Vv}{\\partial x} & \\frac{\\partial u_{m2}}{\\partial x} \\Vv + u_{m2} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & \\frac{\\partial u_{mn}}{\\partial x} \\Vv + u_{mn} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} \\Vv & \\frac{\\partial u_{12}}{\\partial x} \\Vv & \\cdots & \\frac{\\partial u_{1n}}{\\partial x} \\Vv \\\\ \\frac{\\partial u_{21}}{\\partial x} \\Vv & \\frac{\\partial u_{22}}{\\partial x} \\Vv & \\cdots & \\frac{\\partial u_{2n}}{\\partial x} \\Vv \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} \\Vv & \\frac{\\partial u_{m2}}{\\partial x} \\Vv & \\cdots & \\frac{\\partial u_{mn}}{\\partial x} \\Vv \\\\ \\end{bmatrix} + \\begin{bmatrix} u_{11} \\frac{\\partial \\Vv}{\\partial x} & u_{12} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & u_{1n} \\frac{\\partial \\Vv}{\\partial x} \\\\ u_{21} \\frac{\\partial \\Vv}{\\partial x} & u_{22} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & u_{2n} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ u_{m1} \\frac{\\partial \\Vv}{\\partial x} & u_{m2} \\frac{\\partial \\Vv}{\\partial x} & \\cdots & u_{mn} \\frac{\\partial \\Vv}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\class{blue}{\\frac{\\partial \\Uv}{\\partial x} \\otimes \\Vv + \\Uv \\otimes \\frac{\\partial \\Vv}{\\partial x}} \\end{align*} 设\\Uv, \\Vv \\in \\Rbb^{m \\times n}，则 \\begin{align*} \\class{blue}{\\frac{\\partial \\Uv \\circ \\Vv}{\\partial x}} & = \\begin{bmatrix} \\frac{\\partial u_{11} v_{11}}{\\partial x} & \\frac{\\partial u_{12} v_{12}}{\\partial x} & \\cdots & \\frac{\\partial u_{1n} v_{1n}}{\\partial x} \\\\ \\frac{\\partial u_{21} v_{21}}{\\partial x} & \\frac{\\partial u_{22} v_{22}}{\\partial x} & \\cdots & \\frac{\\partial u_{2n} v_{2n}}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1} v_{m1}}{\\partial x} & \\frac{\\partial u_{m2} v_{m2}}{\\partial x} & \\cdots & \\frac{\\partial u_{mn} v_{mn}}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\begin{bmatrix} \\frac{\\partial u_{11}}{\\partial x} v_{11} & \\frac{\\partial u_{12}}{\\partial x} v_{12} & \\cdots & \\frac{\\partial u_{1n}}{\\partial x} v_{1n} \\\\ \\frac{\\partial u_{21}}{\\partial x} v_{21} & \\frac{\\partial u_{22}}{\\partial x} v_{22} & \\cdots & \\frac{\\partial u_{2n}}{\\partial x} v_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial u_{m1}}{\\partial x} v_{m1} & \\frac{\\partial u_{m2}}{\\partial x} v_{m2} & \\cdots & \\frac{\\partial u_{mn}}{\\partial x} v_{mn} \\\\ \\end{bmatrix} + \\begin{bmatrix} u_{11} \\frac{\\partial v_{11}}{\\partial x} & u_{12} \\frac{\\partial v_{12}}{\\partial x} & \\cdots & u_{1n} \\frac{\\partial v_{1n}}{\\partial x} \\\\ u_{21} \\frac{\\partial v_{21}}{\\partial x} & u_{22} \\frac{\\partial v_{22}}{\\partial x} & \\cdots & u_{2n} \\frac{\\partial v_{2n}}{\\partial x} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ u_{m1} \\frac{\\partial v_{m1}}{\\partial x} & u_{m2} \\frac{\\partial v_{m2}}{\\partial x} & \\cdots & u_{mn} \\frac{\\partial v_{mn}}{\\partial x} \\\\ \\end{bmatrix} \\\\ & = \\class{blue}{\\frac{\\partial \\Uv}{\\partial x} \\circ \\Vv + \\Uv \\circ \\frac{\\partial \\Vv}{\\partial x}} \\end{align*} 　　设多项式函数g(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \\cdots，则g'(x) = a_1 + 2 a_2 x + 3 a_3 x^2 + \\cdots，若\\Av为与x无关的方阵，记 \\begin{align*} g (x \\Av) & = a_0 \\Iv + a_1 x \\Av + a_2 x^2 \\Av^2 + a_3 x^3 \\Av^3 + \\cdots \\\\ g' (x \\Av) & = a_1 \\Iv + 2 a_2 x \\Av + 3 a_3 x^2 \\Av^2 + \\cdots \\end{align*} 易知有 \\begin{align*} \\class{blue}{\\frac{\\partial g(x \\Av)}{\\partial x}} & = a_1 \\Av + 2 a_2 x \\Av^2 + 3 a_3 x^2 \\Av^3 + \\cdots \\\\ & = \\Av (a_1 \\Iv + 2 a_2 x \\Av + 3 a_3 x^2 \\Av^2 + \\cdots) = \\class{blue}{\\Av g' (x \\Av)} \\\\ & = (a_1 \\Iv + 2 a_2 x \\Av + 3 a_3 x^2 \\Av^2 + \\cdots) \\Av = \\class{blue}{g' (x \\Av) \\Av} \\end{align*} 对于e^x、\\ln x、\\sin x、\\cos x，上式依然适用，例如 \\begin{align*} \\frac{\\partial e^{x \\Av}}{\\partial x} = \\Av e^{x \\Av} = e^{x \\Av} \\Av \\end{align*} 标量对矩阵求导 　　矩阵常见的标量函数有迹和行列式，二次型可以归为迹来处理。 迹对矩阵求导 　　若a与\\Xv无关，\\Uv = \\Uv(\\Xv)，\\Vv = \\Vv(\\Xv)，则以下结论是显然的： \\begin{align*} \\frac{\\partial \\tr(\\Xv)}{\\partial \\Xv} = \\Iv, \\quad \\frac{\\partial \\tr(\\Uv+\\Vv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Uv)}{\\partial \\Xv} + \\frac{\\partial \\tr(\\Vv)}{\\partial \\Xv}, \\quad \\frac{\\partial \\tr(a \\Uv)}{\\partial \\Xv} = a \\frac{\\partial \\tr(\\Uv)}{\\partial \\Xv} \\end{align*} 对于乘积有 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Uv \\Vv)}{\\partial \\Xv} \\right]_{ij} & = \\class{blue}{\\frac{\\partial \\tr(\\Uv \\Vv)}{\\partial x_{ji}}} = \\frac{\\partial \\sum_p \\sum_q u_{pq} v_{qp}}{\\partial x_{ji}} = \\sum_p \\sum_q \\left( \\frac{\\partial u_{pq}}{\\partial x_{ji}} v_{qp} + u_{pq} \\frac{\\partial v_{qp}}{\\partial x_{ji}} \\right) \\\\ & = \\class{blue}{\\tr \\left( \\frac{\\partial \\Uv}{\\partial x_{ji}} \\Vv \\right) + \\tr \\left( \\Uv \\frac{\\partial \\Vv}{\\partial x_{ji}} \\right)} = \\tr \\left( \\frac{\\partial \\Uv \\Vv}{\\partial x_{ji}} \\right) \\end{align*} 由此可知迹和求导的顺序可以交换。特别的， 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Bv \\Av \\Xv)}{\\partial \\Xv} \\right]_{ij} = \\tr \\left( \\Bv \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) = \\tr ( \\Bv \\Av \\Ev_{ji} ) = [\\Bv \\Av]_{ij} \\Longrightarrow \\frac{\\partial \\tr(\\Bv \\Av \\Xv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av \\Xv \\Bv)}{\\partial \\Xv} = \\Bv \\Av \\end{align*} 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv^\\top，则 \\begin{align*} \\frac{\\partial \\tr(\\Bv \\Av \\Xv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv \\Av^\\top \\Bv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av^\\top \\Bv^\\top \\Xv)}{\\partial \\Xv} = \\Av^\\top \\Bv^\\top \\end{align*} 取\\Uv = \\Av与\\Xv无关，\\Vv = \\Xv \\Xv^\\top，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv \\Xv^\\top)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Av \\frac{\\partial \\Xv \\Xv^\\top}{\\partial x_{ji}} \\right) = \\tr \\left( \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^\\top \\right) + \\tr \\left( \\Av \\Xv \\frac{\\partial \\Xv^\\top}{\\partial x_{ji}} \\right) \\\\ & = \\tr(\\Av \\Ev_{ji} \\Xv^\\top) + \\tr(\\Av \\Xv \\Ev_{ij}) \\\\ & = [\\Xv^\\top \\Av]_{ij} + [\\Av \\Xv]_{ji} \\end{align*} 从而 \\begin{align*} \\frac{\\partial \\tr(\\Av \\Xv \\Xv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv^\\top \\Av \\Xv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv \\Xv^\\top \\Av)}{\\partial \\Xv} = \\Xv^\\top \\Av + \\Xv^\\top \\Av^\\top = \\Xv^\\top (\\Av + \\Av^\\top) \\end{align*} 取\\Uv = \\Av与\\Xv无关，\\Vv = \\Xv^\\top \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Xv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Av \\frac{\\partial \\Xv^\\top \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\Av \\frac{\\partial \\Xv^\\top}{\\partial x_{ji}} \\Xv \\right) + \\tr \\left( \\Av \\Xv^\\top \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) \\\\ & = \\tr(\\Av \\Ev_{ij} \\Xv) + \\tr(\\Av \\Xv^\\top \\Ev_{ji}) \\\\ & = [\\Xv \\Av]_{ji} + [\\Av \\Xv^\\top]_{ij} \\end{align*} 从而 \\begin{align*} \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Xv)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv \\Av \\Xv^\\top)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Xv^\\top \\Xv \\Av)}{\\partial \\Xv} = (\\Av + \\Av^\\top) \\Xv^\\top \\end{align*} 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv^{-1}，结合式(\\ref{eq: inverse})可得 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Bv \\Av \\Xv^{-1})}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Bv \\Av \\frac{\\partial \\Xv^{-1}}{\\partial x_{ji}} \\right) = \\tr \\left( - \\Bv \\Av \\Xv^{-1} \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^{-1} \\right) \\\\ & = - \\tr \\left( \\Xv^{-1} \\Bv \\Av \\Xv^{-1} \\Ev_{ji} \\right) = - [\\Xv^{-1} \\Bv \\Av \\Xv^{-1}]_{ij} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Bv \\Av \\Xv^{-1})}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av \\Xv^{-1} \\Bv)}{\\partial \\Xv} = - \\Xv^{-1} \\Bv \\Av \\Xv^{-1} \\end{align*} 取\\Uv = \\Iv，\\Vv = (\\Xv + \\Av)^{-1}，结合式(\\ref{eq: inverse})可得 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Xv + \\Av)^{-1}}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial (\\Xv + \\Av)^{-1}}{\\partial x_{ji}} \\right) = - \\tr \\left( (\\Xv + \\Av)^{-1} \\frac{\\partial (\\Xv + \\Av)}{\\partial x_{ji}} (\\Xv + \\Av)^{-1} \\right) \\\\ & = - \\tr \\left( (\\Xv + \\Av)^{-1} (\\Xv + \\Av)^{-1} \\Ev_{ji} \\right) = - [(\\Xv + \\Av)^{-1} (\\Xv + \\Av)^{-1}]_{ij} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Xv + \\Av)^{-1}}{\\partial \\Xv} = - (\\Xv + \\Av)^{-1} (\\Xv + \\Av)^{-1} \\end{align*} 取\\Uv = \\Av \\Xv \\Bv，\\Vv = \\Xv^\\top \\Cv，其中\\Av、\\Bv、\\Cv与\\Xv无关，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv \\Bv \\Xv^\\top \\Cv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial \\Av \\Xv \\Bv}{\\partial x_{ji}} \\Xv^\\top \\Cv \\right) + \\tr \\left( \\Av \\Xv \\Bv \\frac{\\partial \\Xv^\\top \\Cv}{\\partial x_{ji}} \\right) \\\\ & = \\tr \\left( \\Av \\Ev_{ji} \\Bv \\Xv^\\top \\Cv \\right) + \\tr \\left( \\Av \\Xv \\Bv \\Ev_{ij} \\Cv \\right) \\\\ & = [\\Bv \\Xv^\\top \\Cv \\Av]_{ij} + [\\Cv \\Av \\Xv \\Bv]_{ji} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Av \\Xv \\Bv \\Xv^\\top \\Cv)}{\\partial \\Xv} = \\Bv \\Xv^\\top \\Cv \\Av + \\Bv^\\top \\Xv^\\top \\Av^\\top \\Cv^\\top \\end{align*} 取\\Uv = \\Av \\Xv^\\top \\Bv，\\Vv = \\Xv \\Cv，其中\\Av、\\Bv、\\Cv与\\Xv无关，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Bv \\Xv \\Cv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial \\Av \\Xv^\\top \\Bv}{\\partial x_{ji}} \\Xv \\Cv \\right) + \\tr \\left( \\Av \\Xv^\\top \\Bv \\frac{\\partial \\Xv \\Cv}{\\partial x_{ji}} \\right) \\\\ & = \\tr \\left( \\Av \\Ev_{ij} \\Bv \\Xv \\Cv \\right) + \\tr \\left( \\Av \\Xv^\\top \\Bv \\Ev_{ji} \\Cv \\right) \\\\ & = [\\Bv \\Xv \\Cv \\Av]_{ji} + [\\Cv \\Av \\Xv^\\top \\Bv]_{ij} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Av \\Xv^\\top \\Bv \\Xv \\Cv)}{\\partial \\Xv} = \\Cv \\Av \\Xv^\\top \\Bv + \\Av^\\top \\Cv^\\top \\Xv^\\top \\Bv^\\top \\end{align*} 取\\Uv = \\Bv \\Av与\\Xv无关，\\Vv = \\Xv^n，其中n是正整数，结合式(\\ref{eq: power})可得 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Bv \\Av \\Xv^n)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Bv \\Av \\frac{\\partial \\Xv^n}{\\partial x_{ji}} \\right) = \\tr \\left( \\Bv \\Av \\sum_{k \\in [n]} \\Xv^{k-1} \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^{n-k} \\right) = \\sum_{k \\in [n]} \\tr \\left( \\Bv \\Av \\Xv^{k-1} \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Xv^{n-k} \\right) \\\\ & = \\sum_{k \\in [n]} \\tr ( \\Xv^{n-k} \\Bv \\Av \\Xv^{k-1} \\Ev_{ji} ) = \\sum_{k \\in [n]} [\\Xv^{n-k} \\Bv \\Av \\Xv^{k-1}]_{ij} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Bv \\Av \\Xv^n)}{\\partial \\Xv} = \\frac{\\partial \\tr(\\Av \\Xv^n \\Bv)}{\\partial \\Xv} = \\sum_{k \\in [n]} \\Xv^{n-k} \\Bv \\Av \\Xv^{k-1} \\end{align*} 进一步若\\Av = \\Bv = \\Iv，则 \\begin{align*} \\frac{\\partial \\tr(\\Xv^n)}{\\partial \\Xv} = \\sum_{k \\in [n]} \\Xv^{n-k} \\Xv^{k-1} = \\sum_{k \\in [n]} \\Xv^{n-1} = n \\Xv^{n-1} \\end{align*} 不难发现形式上和单变量的求导公式\\partial x^n / \\partial x = n x^{n-1}是一样的。类似的记 \\begin{align*} e^{\\Xv} & = \\Iv + \\Xv + \\frac{\\Xv^2}{2!} + \\frac{\\Xv^3}{3!} + \\cdots \\\\ \\sin \\Xv & = \\Xv - \\frac{\\Xv^3}{3!} + \\frac{\\Xv^5}{5!} - \\cdots \\\\ \\cos \\Xv & = \\Iv - \\frac{\\Xv^2}{2!} + \\frac{\\Xv^4}{4!} - \\frac{\\Xv^6}{6!} + \\cdots \\end{align*} 结合式(\\ref{eq: power})可得 \\begin{align*} \\frac{\\partial \\tr(e^{\\Xv})}{\\partial \\Xv} & = \\frac{\\partial }{\\partial \\Xv} \\tr \\left( \\Iv + \\Xv + \\frac{\\Xv^2}{2!} + \\frac{\\Xv^3}{3!} + \\cdots \\right) \\\\ & = \\frac{\\partial \\tr (\\Iv)}{\\partial \\Xv} + \\frac{\\partial \\tr (\\Xv)}{\\partial \\Xv} + \\frac{1}{2!} \\frac{\\partial \\tr (\\Xv^2)}{\\partial \\Xv} + \\frac{1}{3!} \\frac{\\partial \\tr (\\Xv^3)}{\\partial \\Xv} + \\cdots \\\\ & = \\Iv + \\Xv + \\frac{\\Xv^2}{2!} + \\cdots = e^{\\Xv} \\end{align*} 以及 \\begin{align*} \\frac{\\partial \\tr(\\sin \\Xv)}{\\partial \\Xv} & = \\frac{\\partial }{\\partial \\Xv} \\tr \\left( \\Xv - \\frac{\\Xv^3}{3!} + \\frac{\\Xv^5}{5!} - \\cdots \\right) \\\\ & = \\frac{1}{1!} \\frac{\\partial \\tr (\\Xv)}{\\partial \\Xv} - \\frac{1}{3!} \\frac{\\partial \\tr (\\Xv^3)}{\\partial \\Xv} + \\frac{1}{5!} \\frac{\\partial \\tr (\\Xv^5)}{\\partial \\Xv} - \\cdots \\\\ & = \\Iv - \\frac{\\Xv^2}{2!} + \\frac{\\Xv^4}{4!} - \\cdots = \\cos \\Xv \\\\ \\frac{\\partial \\tr(\\cos \\Xv)}{\\partial \\Xv} & = \\frac{\\partial }{\\partial \\Xv} \\tr \\left( \\Iv - \\frac{\\Xv^2}{2!} + \\frac{\\Xv^4}{4!} - \\frac{\\Xv^6}{6!} + \\cdots \\right) \\\\ & = \\frac{\\partial \\tr (\\Iv)}{\\partial \\Xv} - \\frac{1}{2!} \\frac{\\partial \\tr (\\Xv^2)}{\\partial \\Xv} + \\frac{1}{4!} \\frac{\\partial \\tr (\\Xv^4)}{\\partial \\Xv} - \\frac{1}{6!} \\frac{\\partial \\tr (\\Xv^6)}{\\partial \\Xv} + \\cdots \\\\ & = - \\Xv + \\frac{\\Xv^3}{3!} - \\frac{\\Xv^5}{5!} + \\cdots = - \\sin \\Xv \\end{align*} 均与单变量的求导公式一样。 取\\Uv = \\Iv，\\Vv = \\Av \\otimes \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Av \\otimes \\Xv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial \\Av \\otimes \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\Av \\otimes \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) = \\tr ( \\Av \\otimes \\Ev_{ji} ) = \\tr(\\Av) \\delta_{ij} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Av \\otimes \\Xv)}{\\partial \\Xv} = \\tr(\\Av) \\Iv \\end{align*} 取\\Uv = \\Iv，\\Vv = \\Xv \\otimes \\Xv，则 \\begin{align*} \\left[ \\frac{\\partial \\tr(\\Xv \\otimes \\Xv)}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial \\Xv \\otimes \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\frac{\\partial \\Xv}{\\partial x_{ji}} \\otimes \\Xv + \\Xv \\otimes \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) \\\\ & = \\tr ( \\Ev_{ji} \\otimes \\Xv ) + \\tr ( \\Xv \\otimes \\Ev_{ji} ) = 2 \\tr(\\Xv) \\delta_{ij} \\\\ & \\Longrightarrow \\frac{\\partial \\tr(\\Xv \\otimes \\Xv)}{\\partial \\Xv} = 2 \\tr(\\Xv) \\Iv \\end{align*} 行列式对矩阵求导 　　设\\Xv \\in \\Rbb^{m \\times n}、\\Av \\in \\Rbb^{l \\times m}、\\Bv \\in \\Rbb^{n \\times l}、\\Yv = \\Av \\Xv \\Bv \\in \\Rbb^{l \\times l}，\\Av、\\Bv与\\Xv无关，结合式(\\ref{eq: chain-matrix})易知 \\begin{align*} \\left[ \\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} \\right]_{ij} = \\frac{\\partial |\\Yv|}{\\partial x_{ji}} = \\sum_p \\sum_q \\frac{\\partial |\\Yv|}{\\partial y_{pq}}\\frac{\\partial y_{pq}}{\\partial x_{ji}} = \\tr \\left( \\frac{\\partial |\\Yv|}{\\partial \\Yv} \\frac{\\partial \\Yv}{\\partial x_{ji}} \\right) \\end{align*} 其中第二项 \\begin{align*} \\frac{\\partial \\Yv}{\\partial x_{ji}} = \\frac{\\partial \\Av \\Xv \\Bv}{\\partial x_{ji}} = \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\Bv = \\Av \\Ev_{ji} \\Bv \\end{align*} 记y_{ji}有一个微小增量\\epsilon后的矩阵为\\Yv(y_{ji} + \\epsilon)，根据第j行Laplace展开易知 \\begin{align*} |\\Yv(y_{ji} + \\epsilon)| - |\\Yv| = \\epsilon C_{ji} \\end{align*} 其中C_{ji}是关于y_{ji}的代数余子式，因此 \\begin{align*} \\left[ \\frac{\\partial |\\Yv|}{\\partial \\Yv} \\right]_{ij} = \\frac{\\partial |\\Yv|}{\\partial y_{ji}} = \\lim_{\\epsilon \\rightarrow 0} \\frac{|\\Yv(y_{ji} + \\epsilon)| - |\\Yv|}{\\epsilon} = C_{ji} \\end{align*} 故第一项 \\begin{align*} \\frac{\\partial |\\Yv|}{\\partial \\Yv} = \\begin{bmatrix} C_{11} & C_{21} & \\cdots & C_{n1} \\\\ C_{12} & C_{22} & \\cdots & C_{n2} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ C_{1n} & C_{2n} & \\cdots & C_{nn} \\end{bmatrix} = \\Yv^* \\end{align*} 代入可得 \\begin{align*} \\left[ \\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\frac{\\partial |\\Yv|}{\\partial \\Yv} \\frac{\\partial \\Yv}{\\partial x_{ji}} \\right) = \\tr (\\Yv^* \\Av \\Ev_{ji} \\Bv) = [\\Bv \\Yv^* \\Av]_{ij} \\\\ & \\Longrightarrow \\class{blue}{\\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} = \\Bv (\\Av \\Xv \\Bv)^* \\Av} \\end{align*} 若\\Xv、\\Av、\\Bv均为可逆方阵，则\\Yv = \\Av \\Xv \\Bv亦为可逆方阵，于是 \\begin{align} \\label{eq: determinant} \\frac{\\partial |\\Av \\Xv \\Bv|}{\\partial \\Xv} = \\Bv (\\Av \\Xv \\Bv)^* \\Av = \\Bv |\\Av \\Xv \\Bv| (\\Av \\Xv \\Bv)^{-1} \\Av = |\\Av \\Xv \\Bv| \\Xv^{-1} \\end{align} 进一步若\\Av = \\Bv = \\Iv，则 \\begin{align*} \\frac{\\partial |\\Xv|}{\\partial \\Xv} = \\Xv^* = |\\Xv| \\Xv^{-1} \\end{align*} 由此可得 \\begin{align*} \\frac{\\partial |\\Xv^n|}{\\partial \\Xv} = \\frac{\\partial |\\Xv|^n}{\\partial \\Xv} = n |\\Xv|^{n-1} \\Xv^* = n |\\Xv|^n \\Xv^{-1} = n |\\Xv^n| \\Xv^{-1} \\end{align*} 若a与\\Xv无关，则 \\begin{align*} \\frac{\\partial \\ln |a \\Xv|}{\\partial \\Xv} = \\frac{\\partial \\ln a^m |\\Xv|}{\\partial \\Xv} = \\frac{\\partial \\ln a^m}{\\partial \\Xv} + \\frac{\\partial \\ln |\\Xv|}{\\partial \\Xv} = \\frac{1}{|\\Xv|} \\frac{\\partial |\\Xv|}{\\partial \\Xv} = \\frac{\\Xv^*}{|\\Xv|} = \\Xv^{-1} \\end{align*} 　　设\\Xv \\in \\Rbb^{m \\times n}、\\Av \\in \\Rbb^{m \\times m}、\\Yv = \\Xv^\\top \\Av \\Xv \\in \\Rbb^{n \\times n}可逆，\\Av与\\Xv无关，易知有 \\begin{align*} \\left[ \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} \\right]_{ij} & = \\tr \\left( \\Yv^* \\frac{\\partial \\Xv^\\top \\Av \\Xv}{\\partial x_{ji}} \\right) = \\tr \\left( \\Yv^* \\frac{\\partial \\Xv^\\top}{\\partial x_{ji}} \\Av \\Xv \\right) + \\tr \\left( \\Yv^* \\Xv^\\top \\Av \\frac{\\partial \\Xv}{\\partial x_{ji}} \\right) \\\\ & = \\tr ( \\Yv^* \\Ev_{ij} \\Av \\Xv ) + \\tr ( \\Yv^* \\Xv^\\top \\Av \\Ev_{ji} ) = [\\Av \\Xv \\Yv^*]_{ji} + [\\Yv^* \\Xv^\\top \\Av]_{ij} \\end{align*} 于是 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} & = (\\Av \\Xv \\Yv^*)^\\top + \\Yv^* \\Xv^\\top \\Av = (\\Av \\Xv |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1})^\\top + |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av \\\\ & = |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av^\\top \\Xv)^{-1} \\Xv^\\top \\Av^\\top + |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av \\\\ & = |\\Xv^\\top \\Av \\Xv| ((\\Xv^\\top \\Av^\\top \\Xv)^{-1} \\Xv^\\top \\Av^\\top + (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av) \\end{align*} 若\\Av对称，则 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} = 2 |\\Xv^\\top \\Av \\Xv| (\\Xv^\\top \\Av \\Xv)^{-1} \\Xv^\\top \\Av \\end{align*} 若\\Xv、\\Av是方阵，则其均可逆，于是 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Av \\Xv|}{\\partial \\Xv} = 2 |\\Xv^\\top| |\\Av| |\\Xv| \\Xv^{-1} \\Av^{-1} \\Xv^{-\\top} \\Xv^\\top \\Av = 2 |\\Xv|^2 |\\Av| \\Xv^{-1} \\end{align*} 若\\Av = \\Iv，则 \\begin{align*} \\frac{\\partial |\\Xv^\\top \\Xv|}{\\partial \\Xv} = 2 |\\Xv^\\top \\Xv| (\\Xv^\\top \\Xv)^{-1} \\Xv^\\top = 2 |\\Xv^\\top \\Xv| \\Xv^\\dagger \\end{align*} 以及 \\begin{align*} \\frac{\\partial \\ln |\\Xv^\\top \\Xv|}{\\partial \\Xv} = \\frac{1}{|\\Xv^\\top \\Xv|} \\frac{\\partial |\\Xv^\\top \\Xv|}{\\partial \\Xv} = 2 \\Xv^\\dagger \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-04 22:27:39 "},"posts/matrix/TU-matrix.html":{"url":"posts/matrix/TU-matrix.html","title":"全幺模矩阵","keywords":"","body":"　　若矩阵\\Av的任意子方阵的行列式\\in \\{ 0, \\pm 1 \\}，则称\\Av为全幺模矩阵(totally unimodular matrix)。 　　若\\Av是全幺模矩阵，则 \\Av的任意子矩阵\\Bv也是全幺模矩阵，因为\\Bv的任意子方阵也是\\Av的子方阵，特别的，\\Av的任意元素都\\in \\{ 0, \\pm 1 \\}。 -\\Av是全幺模矩阵，设\\Av'是-\\Av的任意子方阵，则-\\Av'是\\Av的子方阵，于是\\det(-\\Av') \\in \\{ 0, \\pm 1 \\}，从而\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 \\Av^\\top是全幺模矩阵，设\\Av'是\\Av^\\top的任意子方阵，则\\Av'^\\top是\\Av的子方阵，于是\\det(\\Av'^\\top) \\in \\{ 0, \\pm 1 \\}，从而\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 把\\Av的两行/两列互换得到的矩阵\\Bv是全幺模矩阵，因为\\Bv的任意子方阵都可以通过\\Av的某个子方阵交换行/列得到，而交换行/列只改变行列式的符号。 [\\Av, \\pm \\Av]是全幺模矩阵，设\\Bv是[\\Av, \\pm \\Av]的任意子方阵，则\\Bv的每一列要么来自于\\Av的某一列，要么来自于\\pm \\Av的某一列。若有两列相同或仅差一个符号，则\\Bv是奇异矩阵，从而\\det(\\Bv) = 0；否则\\Bv可直接由\\Av的某个子方阵得到(最多对部分列再取反)，这只会影响行列式的符号，因此\\det(\\Bv) \\in \\{ \\pm 1 \\}。 [\\Av, \\pm \\Iv]是全幺模矩阵，设\\Bv是[\\Av, \\pm \\Iv]的任意非奇异子方阵，若\\Bv是\\Av或\\pm \\Iv其中之一的子方阵，易知有|\\det(\\Bv)| = 1，否则设\\Bv = [\\overline{\\Av}, \\pm \\overline{\\Iv}]，其中\\overline{\\Av}、\\overline{\\Iv}分别是\\Av或\\Iv的子矩阵且都是列满秩的(否则\\Bv奇异)，互换\\Bv的某些行可得 \\begin{align*} \\overline{\\Bv} = \\begin{bmatrix} \\overline{\\Av}_1 & \\zerov \\\\ \\overline{\\Av}_2 & \\pm \\hat{\\Iv} \\end{bmatrix} \\end{align*} 于是|\\det(\\overline{\\Bv})| = |\\det(\\overline{\\Av}_1)| \\cdot |\\det(\\pm \\hat{\\Iv})| = |\\det(\\overline{\\Av}_1)|，而\\overline{\\Av}_1是\\Av的某个非奇异子方阵交换行得到的，故|\\det(\\Bv)| = |\\det(\\overline{\\Bv})| = |\\det(\\overline{\\Av}_1)| = 1。 [\\Av; \\pm \\Iv]是全幺模矩阵，因为[\\Av; \\pm \\Iv] = [\\Av^\\top, \\pm \\Iv]^\\top，其中\\Av^\\top是全幺模矩阵，故[\\Av^\\top, \\pm \\Iv]是全幺模矩阵，取转置后依然是全幺模矩阵。 　　全幺模矩阵跟图有很多联系。 定理1. 设\\Av \\in \\{ 0, \\pm 1 \\}^{m \\times n}是全幺模矩阵，\\bv \\in \\Zbb^m是整数向量，则凸多面体\\Pcal = \\{ \\xv \\in \\Rbb^n \\mid \\Av \\xv \\leq \\bv \\}的极点都是整数向量。 证明：设\\vv是\\Pcal的极点，则存在n元下标集合\\Ical \\subseteq [m]使得\\Av_{\\Ical,:} \\vv = \\bv_{\\Ical}，由Cramer法则知 \\begin{align*} v_i = \\frac{\\det(\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical})}{\\det(\\Av_{\\Ical,:})} \\end{align*} 其中\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical}是将\\Av_{\\Ical,:}的第i列替换成\\bv_{\\Ical}得到的矩阵。注意\\Av_{\\Ical,:}是\\Av的n阶非奇异子方阵，因此\\det(\\Av_{\\Ical,:}) = \\pm 1。将\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical}按第i列展开，由于\\bv_{\\Ical}是整数向量，而展开中涉及的代数余子式又都\\in \\{ 0, \\pm 1 \\}，因此\\det(\\Av_{\\Ical,:}^{(i)}|\\bv_{\\Ical})也是整数，故v_i是整数。 定理2. 对于二部图\\Gcal = (\\Vcal = \\Vcal_1 \\uplus \\Vcal_2, \\Ecal)，其关联矩阵\\Av \\in \\{ 0,1 \\}^{|\\Vcal| \\times |\\Ecal|}是全幺模矩阵。 证明：对子矩阵的阶数k做归纳，k=1的情形是显然的，因为\\Av的每个元素都\\in \\{ 0,1 \\} \\subseteq \\{ 0, \\pm 1 \\}。设\\Av'是\\Av的k阶子矩阵，注意\\Av'的每列最多有两个1，其余均为零。 若有一列全零，则\\Av'为奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 若有一列恰有一个1，按该列展开，设\\Av''是将1所在行、列删除后得到的矩阵，则\\det(\\Av') = \\pm \\det (\\Av'')，由归纳假设知\\det (\\Av'') \\in \\{ 0, \\pm 1 \\}，故\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 若每列都有两个1，由于\\Gcal是二部图，可将\\Av'按行分成两部分，分别对应\\Vcal_1中的点和\\Vcal_2中的点，显然第一部分的行和减去第二部分行和为\\zerov，故\\Av'是奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 定理3. 有向图\\Gcal = (\\Vcal, \\Ecal)的关联矩阵\\Av \\in \\{ 0, \\pm 1 \\}^{|\\Vcal| \\times |\\Ecal|}是全幺模矩阵。 证明：对子矩阵的阶数k做归纳，k=1的情形是显然的，因为\\Av的每个元素都\\in \\{ 0, \\pm 1 \\}。设\\Av'是\\Av的k阶子矩阵，注意\\Av'的每列最多有两个非零元素，其余均为零。 若有一列全零，则\\Av'为奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 若有一列恰有一个1或-1，按该列展开，设\\Av''是将非零元素所在行、列删除后得到的矩阵，则\\det(\\Av') = \\pm \\det (\\Av'')，由归纳假设知\\det (\\Av'') \\in \\{ 0, \\pm 1 \\}，故\\det(\\Av') \\in \\{ 0, \\pm 1 \\}。 若每列都有一个1、一个-1，则\\Av'的所有行相加为\\zerov，故\\Av'是奇异矩阵，从而\\det(\\Av') = 0 \\in \\{ 0, \\pm 1 \\}。 附录 　　考虑线性方程组x_1 \\av_1 + x_2 \\av_2 + \\cdots + x_n \\av_n = \\bv，易知 \\begin{align*} \\det (\\cdots, \\av_{i-1}, \\bv, \\av_{i+1}, \\cdots) & = \\det (\\cdots, \\av_{i-1}, \\sum_{j \\in [n]} x_j \\av_j, \\av_{i+1}, \\cdots) \\\\ & = \\sum_{j \\in [n]} x_j \\det (\\cdots, \\av_{i-1}, \\av_j, \\av_{i+1}, \\cdots) \\\\ & = x_i \\det (\\cdots, \\av_{i-1}, \\av_i, \\av_{i+1}, \\cdots) \\end{align*} 故 \\begin{align*} x_i = \\frac{\\det (\\cdots, \\av_{i-1}, \\bv, \\av_{i+1}, \\cdots)}{\\det (\\cdots, \\av_{i-1}, \\av_i, \\av_{i+1}, \\cdots)} \\end{align*} 该求解公式称为Cramer法则。 　　 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-08 22:40:58 "},"posts/determinant/Cauchy-Binet.html":{"url":"posts/determinant/Cauchy-Binet.html","title":"Cauchy-Binet公式","keywords":"","body":"　　众所周知对于方阵\\Av、\\Bv有 \\begin{align} \\label{eq: det-product} \\det(\\Av \\Bv) = \\det(\\Av) \\det(\\Bv) \\end{align} 更一般的设\\Av \\in \\Rbb^{m \\times n}、\\Bv \\in \\Rbb^{n \\times m}，记S_{[n],m}为集合[n]的所有m元子集构成的集合，则 \\begin{align} \\label{eq: Cauchy-Binet} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align} 这就是Cauchy-Binet公式。 　　考虑三种情况： m = n，此时S_{[n],n}中只有一个元素，就是[n]，式(\\ref{eq: Cauchy-Binet})就退化成了式(\\ref{eq: det-product})； m > n，此时S_{[n],m}是个空集，因此式(\\ref{eq: Cauchy-Binet})等号右边的求和为零，而左边是个秩为n的m阶方阵，非满秩矩阵对应的行列式值为零； m ，举个简单的例子，n=3、m=2、S_{[n],m} = \\{ \\{1,2\\}, \\{2,3\\}, \\{1,3\\} \\}，此时有 \\begin{align*} \\left| \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\end{bmatrix} \\begin{bmatrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{bmatrix} \\right| = \\underbrace{\\left| \\begin{matrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\end{matrix} \\right|}_{S=\\{1,2\\}} + \\underbrace{\\left| \\begin{matrix} a_{12} & a_{13} \\\\ a_{22} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{2,3\\}} + \\underbrace{\\left| \\begin{matrix} a_{11} & a_{13} \\\\ a_{21} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{1,3\\}} \\end{align*} 　　下面给出一个简单的证明，记\\Av的列分别为\\av_1, \\ldots, \\av_n，则 \\begin{align*} \\Av \\Bv = \\begin{bmatrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{bmatrix} \\end{align*} 即\\Av \\Bv的每一列都是\\av_1, \\ldots, \\av_n的线性组合。下面依次展开每一列，易知 \\begin{align*} \\det(\\Av \\Bv) & = | \\begin{matrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\\\ & = b_{11} | \\begin{matrix} \\av_1 & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n1} | \\begin{matrix} \\av_n & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\end{align*} 接着展开第二列，易知上式右边的每一项又会拆分成n项，即 \\begin{align*} \\forall k \\in [n], \\quad & b_{k1} | \\begin{matrix} \\av_k & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | = b_{k1} (b_{12} | \\begin{matrix} \\av_k & \\av_1 & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n2} | \\begin{matrix} \\av_k & \\av_n & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} |) \\end{align*} 最终全部m列展开完毕，将会得到n^m项： \\begin{align*} \\det(\\Av \\Bv) = \\sum_{\\phi} b_{\\phi(1),1} b_{\\phi(2),2} \\cdots b_{\\phi(m),m} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | \\end{align*} 其中\\phi是[m] \\mapsto [n]的映射，求和遍历所有这样的映射。注意若行列式两列相同，行列式值为零，因此实际我们只需考虑单射，这样上式的求和项中就只剩下A_n^m项。 　　对于任一满足\\phi(1) 的项，显然它的行列式中的部分是\\Av的某个m阶子方阵，故 \\begin{align*} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = \\det(\\Av_{[m], S}) \\end{align*} 其中S = \\{\\phi(1), \\phi(2), \\ldots, \\phi(m)\\}。现考虑其它行列式也由\\av_{\\phi(1)}, \\ldots, \\av_{\\phi(m)}构成的项，这样的项有m!个，均呈型 \\begin{align*} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | \\end{align*} 其中\\sigma是S \\mapsto S的置换，由于行列式交换两列，值不变符号取反，因此 \\begin{align*} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} \\det(\\Av_{[m], S}) \\end{align*} 其中\\sgn (\\sigma)是\\sigma产生的逆序对的个数。所有这样的项求和为 \\begin{align*} \\left( \\sum_{\\sigma} (-1)^{\\sgn (\\sigma)} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} \\right) \\det(\\Av_{[m], S}) \\end{align*} 注意括号中的部分就是\\Bv的第\\phi(1), \\ldots, \\phi(m)行构成的m阶子方阵的行列式展开，因此上式等于 \\begin{align*} \\det(\\Av_{[m], S}) \\det(\\Bv_{S,[m]}) \\end{align*} 取遍C_n^m个这样单调递增的\\phi即可得 \\begin{align*} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-03 17:17:39 "},"posts/convex-optimization/extreme-point.html":{"url":"posts/convex-optimization/extreme-point.html","title":"极点的等价定义","keywords":"","body":"　　设凸多面体\\Pcal = \\{ \\xv \\mid \\Av \\xv \\leq \\bv \\} \\subseteq \\Rbb^n，则下面四个条件均可作为极点\\vv的定义： 存在支撑超平面\\Hcal = \\{ \\xv \\mid \\wv^\\top \\xv = \\lambda \\}使得对任意\\xv \\in \\Pcal有\\wv^\\top \\xv \\leq \\lambda且\\Pcal \\cap \\Hcal = \\{ \\vv \\}； \\vv无法表示成\\Pcal \\setminus \\{ \\vv \\}中元素的凸组合； 不存在非零向量\\dv使得\\vv \\pm \\dv \\in \\Pcal； 存在n个约束\\av_i^\\top \\xv \\leq b_i在\\vv处是紧的，即\\av_i^\\top \\vv = b_i，且\\av_1, \\ldots, \\av_n线性无关。 　　证明： 1 \\Rightarrow 2：若\\vv = \\sum_i \\alpha_i \\vv_i，其中\\sum_i \\alpha_i = 1且\\alpha_i \\ge 0，则 \\begin{align*} \\lambda = \\wv^\\top \\vv = \\sum_i \\alpha_i \\wv^\\top \\vv_i \\leq \\sum_i \\alpha_i \\lambda = \\lambda \\end{align*} 故对所有的\\vv_i都有\\wv^\\top \\vv_i = \\lambda，这和\\Pcal、\\Hcal有唯一交集\\vv矛盾。 2 \\Rightarrow 3：若\\vv \\pm \\dv \\in \\Pcal，则\\vv = \\frac{1}{2} (\\vv + \\dv) + \\frac{1}{2} (\\vv - \\dv)是一个凸组合表示，矛盾。 3 \\Rightarrow 4：设所有紧约束的法向量集合为\\Tcal = \\{ \\av_i \\mid \\av_i^\\top \\vv = b_i \\}，若\\dim (\\spn (\\Tcal)) ，即\\Tcal只能张成\\Rbb^n的真子空间，则存在非零向量\\dv与\\spn(\\Tcal)正交，于是 \\begin{align*} & \\av_i^\\top (\\vv + \\epsilon \\dv) = \\av_i^\\top \\vv = b_i, ~ \\forall \\av_i \\in \\Tcal \\\\ & \\av_i^\\top \\vv \\epsilon > 0使得对任意i有\\av_i^\\top (\\vv \\pm \\epsilon \\dv) \\le b_i，故\\vv \\pm \\epsilon \\dv \\in \\Pcal，矛盾。 4 \\Rightarrow 1：构造超平面 \\begin{align*} \\Hcal = \\left\\{ \\xv \\mid \\sum_{i \\in [n]} \\av_i^\\top \\xv = \\sum_{i \\in [n]} b_i \\right\\} \\end{align*} 显然对任意\\xv \\in \\Pcal有\\sum_{i \\in [n]} \\av_i^\\top \\xv \\leq \\sum_{i \\in [n]} b_i。若想取等号，则必须有[\\av_1, \\ldots, \\av_n]^\\top \\xv = [b_1; \\ldots; b_n]，由\\av_1, \\ldots, \\av_n线性无关知该线性方程组有唯一解，即\\vv。 　　 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-04 22:41:08 "},"posts/measure/set-algebra.html":{"url":"posts/measure/set-algebra.html","title":"集合代数","keywords":"","body":"　　对于定积分 \\begin{align*} \\int_a^b f(x) \\diff x \\end{align*} Riemann积分对定义域区间[a,b]进行切分a = a_0 ，然后用上和 \\begin{align*} US = \\sum_{i \\in [n]} \\sup \\{ f(x): x \\in [a_{i-1}, a_i] \\} (a_i - a_{i-1}) \\end{align*} 与下和 \\begin{align*} LS = \\sum_{i \\in [n]} \\inf \\{ f(x): x \\in [a_{i-1}, a_i] \\} (a_i - a_{i-1}) \\end{align*} 对积分值进行夹逼 \\begin{align*} LS \\leq \\int_a^b f(x) \\diff x \\leq US \\end{align*} 　　随着切分越来越细，上和单调减，下和单调增，当积分函数f连续时，两者极限相等且等于积分值，但是当f(非常)不连续时，Riemann积分就会出问题了，比如对Dirichlet函数 \\begin{align*} f(x) = \\begin{cases} 1 & x \\in \\Qbb \\\\ 0 & \\ow \\end{cases} \\end{align*} 无论怎么对定义域切分，下和总是0，上和总是1，极限不相等。为了解决此类问题，Lebesgue积分采用对值域进行切分的方式，对于某个值域区间[a, b]，易知也有上和、下和夹逼： \\begin{align*} \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} a \\diff x \\leq \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} f(x) \\diff x \\leq \\int_{x\\in\\{ a \\leq f(x) \\leq b \\}} b \\diff x \\end{align*} 于是问题就转化为求集合\\{x : a \\leq f(x) \\leq b \\}的“长度”。 　　给集合赋予“长度”是Lebesgue测度论的核心问题，这个问题看似简单，其实很复杂，因为集合可能是无穷点集(上面Dirichlet函数的例子)，也可能是无穷个不相交小区间的并集(在(0,1]上对\\sin (1/x)积分)。事实上，不存在一个普适的长度函数能够对\\Rbb的任意子集都赋予长度，总有些稀奇古怪的异类需要剔除，因此我们引入集合代数的概念，通过定义一些规则，导出一类性质良好可以赋予长度的集合。 　　设\\Omega为非空集合，\\Acal \\subseteq \\Pcal(\\Omega)为其子集构成的集合，对前面的一维积分问题，\\Omega就是\\Rbb，但测度论并不局限于一维积分。例如对n维积分，\\Omega是\\Rbb^n；对概率论，\\Omega是基础事件集合。因此为了保持结论的一般性，我们不将全集写为\\Rbb。 　　集合代数中最简单的结构是环(ring)，其满足三个条件：(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭。这个名字不是随便乱起的，因为定义加法为对称差\\Delta、乘法为交\\cap，(\\Acal, \\Delta, \\cap)就构成了抽象代数里的(交换)环，具体可参见此文。 　　若将环的后两个条件弱化可得到半环(semiring)，其满足：(1).\\emptyset \\subseteq \\Acal；(2).对于\\forall A, B \\in \\Acal，A \\setminus B是\\Acal中有限个不相交集合的并；(3).\\Acal关于\\cap封闭。 　　由于\\cup封闭可保证半环的第二个条件始终满足，而\\setminus封闭可导出\\cap封闭： \\begin{align*} X \\setminus (X \\setminus Y) = X \\setminus (X \\cap \\complement Y) = X \\cap \\complement (X \\cap \\complement Y) = X \\cap (\\complement X \\cup Y) = X \\cap Y \\end{align*} 因此环肯定是半环。但反过来不成立，例如\\Rbb上的全部左开右闭区间构成的集合 \\begin{align*} \\Acal = \\{ (a,b] \\mid a,b \\in \\Rbb, a \\leq b \\} \\end{align*} 就是一个半环，但不是环(关于\\cup不封闭)。事实上，如果半环关于\\cup封闭，则结合第二个条件“A \\setminus B是\\Acal中有限个不相交集合的并”可导出“A \\setminus B是\\Acal中元素”，即关于\\setminus封闭，半环升级成环。 　　若将环的第一个条件改成全集\\Omega \\in \\Acal，则得到代数(algebra)，其满足：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭。 　　由于\\emptyset = (\\Omega \\setminus \\Omega) \\in \\Acal，因此代数肯定是环，但反过来不成立，例如\\Rbb上的全部有界区间的有限并(finite unions)构成的集合就是一个环，但不是代数(全集\\Omega = \\Rbb不属于该集合，因为它无法写成有界区间的有限并)。更一般的，设全集为不可数集合，则其所有可数子集构成的集合就只是环而不是代数。环升级成代数的方法也很简单：先加入全集，然后加入必要的保证\\setminus、\\cup封闭的新元素即可。 　　由于全集的存在，\\setminus封闭可导出\\complement封闭，而由De Morgan律： \\begin{align*} X \\cap Y & = \\complement \\complement (X \\cap Y) = \\complement (\\complement X \\cup \\complement Y) \\\\ X \\cup Y & = \\complement \\complement (X \\cup Y) = \\complement (\\complement X \\cap \\complement Y) \\end{align*} 即在\\complement封闭的前提下，\\cap封闭、\\cup封闭可以互推。又A \\setminus B = A \\cap \\complement B，因此\\cap、\\complement封闭可以导出\\setminus封闭，于是若全集存在，则有 \\begin{align*} \\setminus, \\cup \\text{封闭} \\Longleftrightarrow \\complement, \\cap \\text{封闭} \\Longleftrightarrow \\complement, \\cup \\text{封闭} \\end{align*} 故代数也可等价定义为：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\complement封闭；(3).\\Acal关于\\cap或\\cup封闭。 　　虽然环以\\Delta为加法、\\cap为乘法可构成抽象代数里的交换环(该方式也是唯一的)，但是代数以\\Delta为加法、\\cap为乘法却没有对应的抽象代数结构，易知 \\begin{align*} A \\cap \\Omega = A, \\quad A \\cap \\emptyset = \\emptyset \\end{align*} 即全集\\Omega是乘法运算的单位元，空集\\emptyset是乘法运算的零元(这是环就有的)，但其它非零元素没有乘法逆元，设A \\in \\Acal为非空集，显然不存在其它集合与A的交集等于全集(单位元)，因此代数无法构成抽象代数里的域。 　　前面提到在(0,1]上对\\sin (1/x)积分时，集合\\{x : a \\leq f(x) \\leq b \\}是无穷个不相交小区间的并集，因此我们也要允许可数次并这样的操作，这样就导出了\\sigma-环，其满足：(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于可数次\\cup封闭；以及\\sigma-代数，其满足：(1).\\Omega \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于可数次\\cup封闭。\\sigma-代数也被称为\\sigma-域，但前文表明代数并不对应抽象代数里的域，因此我不喜欢这样的叫法，容易产生误解。\\sigma-环、\\sigma-代数的关系与环、代数的关系一样，前者加入全集，然后再加入必要的保证\\setminus、\\cup封闭的新元素即可得到后者。 　　综上，半环、环、代数、\\sigma-环、\\sigma-代数之间的关系如下： 　　测度论一般采用\\sigma-代数作为考虑对象，即对\\sigma-代数中的任一集合赋予长度。具体到一维积分，这意味着全集\\Rbb是有长度的，若A \\subseteq \\Rbb是\\sigma-代数中的集合，即可以赋予长度，那么\\Rbb \\setminus A也是可以赋予长度的，若A_1, A_2, \\ldots可以赋予长度，那么其并集也可以赋予长度。 　　采用别的结构作为基础建立测度论也不是不可以，只是没有\\sigma-代数那么好用。比如函数f可测的定义是对任意Borel集B \\subseteq \\Rbb，逆象f^{-1} (B) \\in \\Sigma，其中\\Sigma是一个\\sigma-代数。若在\\sigma-环\\Sigma_r上沿用此定义，即对任意Borel集B \\subseteq \\Rbb有f^{-1} (B) \\in \\Sigma_r。由于全集\\Omega = f^{-1} (\\Rbb)，因此要么\\Sigma_r包含全集从而是一个\\sigma-代数，要么任何函数都不可测。若修正定义为对任意Borel集B \\subseteq \\Rbb有\\{ x: f(x) \\neq 0 \\} \\cap f^{-1}(B) \\in \\Sigma_r，此时可避免所有函数不可测的情况，因为即便B = \\Rbb，即f^{-1}(B) = \\Omega，第一项可能会小于全集。但是注意到对任意非零常数函数f，均有\\{ x: f(x) \\neq 0 \\} = \\Omega，因此所有的非零常数函数都是不可测的，进一步这会导出即便f可测，f+1也还是不可测这样反直觉的结果。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-03 17:17:39 "},"posts/measure/set-ring-algebra-ring.html":{"url":"posts/measure/set-ring-algebra-ring.html","title":"此环非彼环乎？","keywords":"","body":"　　学测度论时会碰到某个非空集合\\Omega的子集构成的集合\\Acal \\subseteq \\Pcal(\\Omega)，当其满足(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭，称为环(ring)。众所周知抽象代数里有个数学结构也叫环，其上定义了加法、乘法两个二元运算，并且关于加法构成交换群(commutative group)，关于乘法构成半群(semigroup)，乘法对加法满足分配律。 　　为了区别，下面我们称前者为集合环，后者为代数环。本文说明两者的关系是\\Acal能通过赋予合适的集合上的加法、乘法构成代数(交换)环当且仅当\\Acal是集合环。 　　\\Leftarrow较为简单，给出具体的加法、乘法定义再验证满足代数环公理即可。定义集合环\\Acal中的加法为对称差： \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X), \\quad \\forall X, Y \\in \\Acal \\end{align*} 不难验证(\\Acal, \\Delta)构成交换群，其中交换律是显然的，封闭性由集合环关于\\setminus、\\cup封闭保证，又 \\begin{align*} X \\Delta \\emptyset & = (X \\setminus \\emptyset) \\cup (\\emptyset \\setminus X) = X \\\\ X \\Delta X & = (X \\setminus X) \\cup (X \\setminus X) = \\emptyset \\end{align*} 因此\\emptyset是单位元，逆元就是自身，结合律(X \\Delta Y) \\Delta Z = X \\Delta (Y \\Delta Z)通过集合运算进行验证较为繁琐，根据下面的Venn图易知其成立。 　　定义乘法为\\cap，于是交换律、结合律都是显然的，由于X \\setminus Y = X \\cap \\complement Y，因此 \\begin{align*} X \\setminus (X \\setminus Y) = X \\setminus (X \\cap \\complement Y) = X \\cap \\complement (X \\cap \\complement Y) = X \\cap (\\complement X \\cup Y) = X \\cap Y \\end{align*} 即封闭性也是满足的(这也说明集合环关于\\cup、\\cap、\\setminus都是封闭的)。 　　最后验证\\Delta对于\\cap满足分配律，由于 \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X) = (X \\cap \\complement Y) \\cup (Y \\cap \\complement X) = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\end{align*} 于是 \\begin{align*} (X \\Delta Y) \\cap Z & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\cap Z \\\\ & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y \\cup \\complement Z) \\cap Z \\\\ & = [(X \\cup Y) \\cap Z] \\cap [\\complement X \\cup \\complement Y \\cup \\complement Z] \\\\ & = [(X \\cap Z) \\cup (Y \\cap Z)] \\cap [\\complement (X \\cap Z) \\cup \\complement(Y \\cap Z)] \\\\ & = (X \\cap Z) \\Delta (Y \\cap Z) \\end{align*} 同理易知有 \\begin{align*} Z \\cap (X \\Delta Y) = Z \\cap (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) = (X \\cap Z) \\Delta (Y \\cap Z) = (Z \\cap X) \\Delta (Z \\cap Y) \\end{align*} 综上，若\\Acal \\subseteq \\Pcal(\\Omega)是集合环，则(\\Acal, \\Delta, \\cap)构成代数(交换)环。 　　\\Rightarrow较为复杂，因为我们不知道一个有望构成交换环的集合，它对应的加法、乘法分别是啥，所以我们得先把加法、乘法构造出来。 　　先考虑二元集合R = \\{0, 1\\}构成的交换环(R, +, \\times)，不妨设加法单位元是0，由交换律可知 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1 \\end{align*} 若1 + 1 = 1，则1没有逆元，故1 + 1 = 0，不难验证这样定义的(R, +)构成交换群。由于\\times对+满足分配律，因此 \\begin{align*} 0 \\times 0 = (0 + 0) \\times 0 = 0 \\times 0 + 0 \\times 0 & \\Longrightarrow 0 \\times 0 = 0 \\\\ 0 \\times 1 = (0 + 0) \\times 1 = 0 \\times 1 + 0 \\times 1 & \\Longrightarrow 0 \\times 1 = 0 \\\\ 1 \\times 0 = 1 \\times (0 + 0) = 1 \\times 0 + 1 \\times 0 & \\Longrightarrow 1 \\times 0 = 0 \\end{align*} 最后1 \\times 1无论等于0还是1，(R, \\times)均可构成半群。因此二元集合可构成两种环，加法均为 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1, \\quad 1 + 1 = 0 \\\\ \\end{align*} 乘法分别为 \\begin{align*} 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 0 \\\\ 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 1 \\end{align*} 即只在1 \\times 1的结果上有区别。若加法单位元是1，上述所有运算结果的0和1互换位置，整体结构不变。 　　设R^\\Omega = \\{ f: \\Omega \\mapsto R \\}，由R的特性知每个f都是将\\Omega中的一部分元素映射为0，剩下映射为1，因此R^\\Omega中共有|\\Pcal(\\Omega)|个元素，每个元素均是\\Omega某个子集的特征函数： \\begin{align*} R^\\Omega = \\{ 1_X \\mid X \\in \\Pcal(\\Omega) \\} \\end{align*} 这样就在R^\\Omega和\\Pcal(\\Omega)间建立了一一对应，即g: 1_X \\mapsto X是一个双射。若R^\\Omega想构成环，其上的加法、乘法只能由R上的加法、乘法导出： \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) \\triangleq 1_X(a) + 1_Y(a) \\\\ \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) \\triangleq 1_X(a) \\times 1_Y(a) \\end{align*} 　　根据R上的加法规则有 \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) = \\begin{cases} 0 + 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 + 0 = 1 & \\forall a \\in X \\setminus Y \\\\ 0 + 1 = 1 & \\forall a \\in Y \\setminus X \\\\ 1 + 1 = 0 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 即R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{X \\Delta Y} \\end{align*} 两个集合的特征函数的加和等于其对称差的特征函数。R上的乘法规则不唯一 \\begin{align*} \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) = \\begin{cases} 0 \\times 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 \\times 0 = 0 & \\forall a \\in X \\setminus Y \\\\ 0 \\times 1 = 0 & \\forall a \\in Y \\setminus X \\\\ 1 \\times 1 = 0~\\text{或}~1 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 前者对应任何两个集合的特征函数的乘积都是空集的特征函数，后者对应乘积是交集的特征函数： \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\emptyset ~\\text{或}~ 1_{X \\cap Y} \\end{align*} 　　若R上的加法单位元是1，运算规则中的0和1互换位置，因此导出的R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)} \\end{align*} 同样乘法规则不唯一，其中一个对应任何两个集合的乘积都是全集的特征函数，另一个对应乘积是交集的补集的特征函数，即 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\Omega ~\\text{或}~ 1_{\\complement (X \\cap Y)} \\end{align*} 即在前者的基础上多个取补集的操作(空集的补集是全集)。 　　至此给出了R^\\Omega可能构成的四种交换环 \\begin{align*} & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_\\emptyset) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_{X \\cap Y}) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_\\Omega) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_{\\complement (X \\cap Y)}) \\end{align*} 注意对于第二种交换环有 \\begin{align*} g(1_X \\oplus 1_Y) & = g(1_{X \\Delta Y}) = X \\Delta Y = g(1_X) \\Delta g(1_Y) \\\\ g(1_X \\otimes 1_Y) & = g(1_{X \\cap Y}) = X \\cap Y = g(1_X) \\cap g(1_Y) \\end{align*} 即(\\Pcal(\\Omega), \\Delta, \\cap)同构于(R^\\Omega, \\oplus, \\otimes)，也构成交换环，其他情形没有如此简洁的对应(常用的二元集合运算没有结果恒为空集、全集或两者对称差、交集的补集，除非重新定义)。 　　对\\forall \\Acal \\subseteq \\Pcal(\\Omega)，若其能够构成代数环，则(\\Acal, \\Delta, \\cap)应为(\\Pcal(\\Omega), \\Delta, \\cap)的子环，即\\Acal对\\Delta、\\cap保持封闭，于是对\\forall X, Y \\in \\Acal有 \\begin{align*} \\emptyset & = X \\Delta X \\in \\Acal \\\\ X \\setminus Y & = (X \\Delta Y) \\cap X \\in \\Acal \\\\ X \\cup Y & = (X \\Delta Y) \\Delta (X \\cap Y) \\in \\Acal \\end{align*} 因此\\Acal是集合环。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-03 17:17:39 "},"posts/measure/interval.html":{"url":"posts/measure/interval.html","title":"区间","keywords":"","body":"　　Lebesgue积分的核心问题是给\\Rbb的子集赋予“长度”，而\\Rbb上最简单的子集就是区间，故从区间入手不失为一种途径。 　　区间是拥有凸性的一类子集，共有10种： \\begin{align*} (a,b), \\quad [a,b), \\quad (a,b], \\quad [a,b], \\quad (a,\\infty), \\quad [a,\\infty), \\quad (-\\infty,a), \\quad (-\\infty,a], \\quad (-\\infty, \\infty), \\quad \\emptyset \\end{align*} 其中\\Rbb = (-\\infty, \\infty)就是全集，\\emptyset是其补集，此外[a,a] = \\{ a \\}，因此单点集也属于区间。 　　对任意两个区间I_1、I_2，其交集是一个区间(\\emptyset也是区间)；其并集要么是一个区间，要么存在t满足如下两种情况之一：(1).对\\forall x_1 \\in I_1、\\forall x_2 \\in I_2有x_1 ；(2).对\\forall x_1 \\in I_1、\\forall x_2 \\in I_2有x_2 ；其补集要么是一个区间，要么是两个区间的并集。 　　下面考虑所有由区间的有限并(finite union)构成的集合\\Ical，不难验证\\Ical是一个代数。首先全集\\Rbb = (-\\infty, \\infty) \\in \\Ical；设E_1 = \\cup_{j \\in [n]} I_j \\in \\Ical，E_2 = \\cup_{k \\in [n']} I'_k \\in \\Ical，那么E_1 \\cup E_2显然还是区间的有限并；又 \\begin{align*} E_1 \\cap E_2 = (\\cup_{j \\in [n]} I_j) \\cap (\\cup_{k \\in [n']} I'_k) = \\cup_{j \\in [n]} \\cup_{k \\in [n']} (I_j \\cap I'_k) \\end{align*} 由于I_j \\cap I'_k是一个区间，因此E_1 \\cap E_2也是区间的有限并，从而属于\\Ical，最后由De Morgan律知\\complement E_1 = \\cap_{j \\in [n]} \\complement I_j，而每个\\complement I_j均是区间的有限并，因此其交集也属于\\Ical，故\\Ical是一个代数。 　　对于\\Ical中任一元素E，将能合并成一个区间的都合并掉，则可得到标准形式 \\begin{align*} E = I_1 \\cup \\cdots \\cup I_n \\end{align*} 其中I_1, \\ldots, I_n两两交集为空，且存在t_1, \\ldots, t_{n-1}满足 \\begin{align*} x_1 \\Ical中的任一写成该形式的元素默认为其标准形式。 　　下面考虑给区间赋予长度，直觉上来说区间长度就是其端点的差值，无界区间长度为\\infty，不相交区间的并的长度是它们的长度之和，故引入长度函数m: \\Ical \\mapsto [0, \\infty]： \\begin{align*} & m((a,b)) = m([a,b)) = m((a,b]) = m([a,b]) = b - a, \\quad m(\\emptyset) = 0 \\\\ & m((a,\\infty)) = m([a,\\infty)) = m((-\\infty,a)) = m((-\\infty,a]) = m((-\\infty, \\infty)) = \\infty \\end{align*} 对任意E = I_1 \\cup \\cdots \\cup I_n \\in \\Ical，定义m(E) = \\sum_{j \\in [n]} m(I_j)。 　　上述定义的长度函数m: \\Ical \\mapsto [0, \\infty]满足 有限可加性：设E_1, E_2, \\ldots, E_n \\in \\Ical且两两不相交，则m(\\cup_{j \\in [n]} E_j) = \\sum_{j \\in [n]} m(E_j)； 单调性：设E_1, E_2 \\in \\Ical且E_1 \\subseteq E_2，则m(E_1) \\leq m(E_2)； 有限次可加性：设E_1, E_2, \\ldots \\in \\Ical，则m(\\cup_{j \\in [n]} E_j) \\leq \\sum_{j \\in [n]} m(E_j)； 可数可加性：设E_1, E_2, \\ldots \\in \\Ical且两两不相交，若\\cup_{j=1}^\\infty E_j \\in \\Ical，则m(\\cup_{j=1}^\\infty E_j) = \\sum_{j=1}^\\infty m(E_j)； 可数次可加性：设E_1, E_2, \\ldots \\in \\Ical，若\\cup_{j=1}^\\infty E_j \\in \\Ical，则m(\\cup_{j=1}^\\infty E_j) \\leq \\sum_{j=1}^\\infty m(E_j)； 平移不变性：对\\forall E \\in \\Ical和x_0 \\in \\Rbb，E + x_0 \\triangleq \\{ x + x_0 \\mid x \\in E \\} \\in \\Ical且m(E + x_0) = m(E)。 　　可数可加性、可数次可加性分别是有限可加性、有限次可加性的推广，令E_{n+1} = E_{n+2} = \\cdots = \\emptyset即可由前者导出后者。此外可数(次)可加性的前提是\\cup_{j=1}^\\infty E_j \\in \\Ical，否则m(\\cup_{j=1}^\\infty E_j)没有定义，但这并不要求\\Ical是一个\\sigma-代数。 证明： 只需证明两个集合的情况即可由数学归纳法知结论对任意自然数n都成立。设E_1 \\cup E_2 = \\cup_{j \\in [n']} I_j，则m(E_1 \\cup E_2) = \\sum_{j \\in [n']} m(I_j)。注意构成E_1的每个区间必然都属于某个I_j，故其标准形式为E_1 = \\cup_{j \\in [n']} (E_1 \\cap I_j)，即m(E_1) = \\sum_{j \\in [n']} m(E_1 \\cap I_j)，同理m(E_2) = \\sum_{j \\in [n']} m(E_2 \\cap I_j)，于是待证结论变成 \\begin{align*} \\sum_{j \\in [n']} m(I_j) = \\sum_{j \\in [n']} m(E_1 \\cap I_j) + \\sum_{j \\in [n']} m(E_2 \\cap I_j) \\end{align*} 即只需证m(I_j) = m(E_1 \\cap I_j) + m(E_2 \\cap I_j)。注意E_1 \\cap I_j、E_2 \\cap I_j不相交，因此其标准形式中的所有区间均两两不相交，又这些区间的并集是区间I_j，因此这些区间写成标准形式是首尾相连的(前一个区间的右端点等于后一个区间的左端点)，从而m(I_j) = m(E_1 \\cap I_j) + m(E_2 \\cap I_j)。 若E_1 \\subseteq E_2，则E_2 = E_1 \\cup (E_2 \\setminus E_1)且E_1 \\cap (E_2 \\setminus E_1) = \\emptyset，由有限可加性和长度函数的非负性知 \\begin{align*} m(E_2) = m(E_1) + m(E_2 \\setminus E_1) \\geq m(E_1) \\end{align*} 只需证明两个集合的情况即可由数学归纳法知结论对任意自然数n都成立。由于E_1 \\cup E_2 = E_1 \\cup (E_2 \\setminus E_1)且E_1 \\cap (E_2 \\setminus E_1) = \\emptyset，又(E_2 \\setminus E_1) \\subseteq E_2，由有限可加性和单调性知 \\begin{align*} m(E_1 \\cup E_2) = m(E_1) + m(E_2 \\setminus E_1) \\leq m(E_1) + m(E_2) \\end{align*} 由有限可加性的证明知只需考虑\\cup_{j=1}^\\infty E_j等于一个区间I的情况，设E_j = \\cup_{k \\in [n_j]} I_{j,k}，于是 \\begin{align*} I = E_1 \\cup E_2 \\cup \\cdots = I_{1,1} \\cup I_{1,2} \\cup \\cdots \\cup I_{1,n_1} \\cup I_{2,1} \\cup I_{2,2} \\cup \\cdots \\cup I_{2,n_2} \\cup I_{3,1} \\cup \\cdots \\end{align*} 由于E_1, E_2, \\ldots两两不相交，因此上式中的可数无穷项I_{j,k}均两两不相交，将其写成标准形式： \\begin{align*} I = I_1 \\cup I_2 \\cup \\cdots = \\cup_{k=1}^\\infty I_k \\end{align*} 注意m(E_j) = \\sum_{k \\in [n_j]} m(I_{j,k})，于是待证结论变成 \\begin{align*} m(I) = m(\\cup_{k=1}^\\infty I_k) = \\sum_{k=1}^\\infty m(I_k) \\end{align*} 对任意自然数n，由有限可加性和单调性知 \\begin{align*} \\sum_{k \\in [n]} m(I_k) = m(\\cup_{k \\in [n]} I_k) \\leq m(\\cup_{k=1}^\\infty I_k) = m(I) \\end{align*} 令n \\rightarrow \\infty可得\\sum_{k=1}^\\infty m(I_k) \\leq m(I)。 下面证明另一个方向，不妨设所有的I_k都是有界区间(否则若某个I_k无界，则I也无界，上式两边都是\\infty)，则对\\forall \\epsilon > 0，存在开区间J_k从外部充分逼近I_k，即I_k \\subseteq J_k且m(J_k) 。引入有界闭区间[a_0, b_0] \\subseteq I，于是 \\begin{align*} [a_0, b_0] \\subseteq I = \\cup_{k=1}^\\infty I_k \\subseteq \\cup_{k=1}^\\infty J_k \\end{align*} 即J_1, J_2, \\ldots是有界闭区间[a_0, b_0]的一个开覆盖(open cover)，由Heine-Borel定理知其存在有限子覆盖，不妨设子覆盖的下标集合是\\Ical'，于是由有限可加性和单调性知 \\begin{align*} a_0 - b_0 = m([a_0, b_0]) \\leq \\sum_{k \\in \\Ical'} m(J_k) I无界，可以选取[a_0, b_0]使得b_0 - a_0任意的大，而\\epsilon又可以任意的小，于是有\\sum_{k=1}^\\infty m(I_k) = \\infty = m(I)；若I有界，选取[a_0, b_0]从内部充分逼近I，即使得b_0 - a_0 > m(I) - \\epsilon，于是有 \\begin{align*} m(I) - \\epsilon \\epsilon可以任意的小，故m(I) \\leq \\sum_{k=1}^\\infty m(I_k)。 综上有m(\\cup_{k=1}^\\infty I_k) = m(I) = \\sum_{k=1}^\\infty m(I_k)。 令F_j = E_j \\setminus (\\cup_{k \\in [j-1]} E_k) \\subseteq E_j，易知F_1, F_2, \\ldots两两不相交且对任意自然数n有\\cup_{j \\in [n]} F_j = \\cup_{j \\in [n]} E_j，于是 \\begin{align*} m(\\cup_{j \\in [n]} E_j) = m(\\cup_{j \\in [n]} F_j) = \\sum_{j \\in [n]} m(F_j) \\leq \\sum_{j \\in [n]} m(E_j) \\end{align*} 令n \\rightarrow \\infty可知m(\\cup_{j=1}^\\infty E_j) \\leq \\sum_{j=1}^\\infty m(E_j)。 设E = \\cup_{j \\in [n]} I_j，则E + x_0 = \\cup_{j \\in [n]} (I_j + x_0)。若I_j有界，设其端点分别为a、b，则I_j + x_0依然有界且端点分别为a + x_0、b + x_0，于是m(I_j + x_0) = (b + x_0) - (a + x_0) = b - a = m(I_j)；若I_j无界，则I_j + x_0也无界(\\pm \\infty + x_0 = \\pm \\infty)，且m(I_j + x_0) = \\infty = m(I_j)，综上有m(E + x_0) = m(E)。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-12-04 22:27:39 "}}