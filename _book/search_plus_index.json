{"./":{"url":"./","title":"简介","keywords":"","body":"数学笔记 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-08-18 08:35:17 "},"posts/matrix/derivative.html":{"url":"posts/matrix/derivative.html","title":"导数","keywords":"","body":"若方阵\\Av可逆，则 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff \\Av} = - \\Av^{-\\top} \\Bv^\\top \\Cv^\\top \\Av^{-\\top} \\end{align*} 证明：由矩阵乘法的线性性，易知有 \\begin{align*} \\frac{\\diff (\\Av \\Bv)}{\\diff x} = \\frac{\\diff \\Av}{\\diff x} \\Bv + \\Av \\frac{\\diff \\Bv}{\\diff x} \\end{align*} 特别地，取\\Bv = \\Av^{-1}且x = a_{ij}可知有 \\begin{align*} \\boldsymbol{0} = \\frac{\\diff \\Iv}{\\diff a_{ij}} = \\frac{\\diff (\\Av \\Av^{-1})}{\\diff a_{ij}} = \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} + \\Av \\frac{\\diff \\Av^{-1}}{\\diff a_{ij}} \\end{align*} 即 \\begin{align*} \\frac{\\diff \\Av^{-1}}{\\diff a_{ij}} = - \\Av^{-1} \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} \\end{align*} 注意\\tr (\\Bv \\Av^{-1} \\Cv) = \\tr (\\Av^{-1} \\Cv \\Bv)，于是 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff a_{ij}} & = \\frac{\\diff (\\tr(\\Av^{-1} \\Cv \\Bv))}{\\diff a_{ij}} = \\tr \\left( \\frac{\\diff (\\Av^{-1} \\Cv \\Bv)}{\\diff a_{ij}} \\right) \\\\ & = \\tr \\left( - \\Av^{-1} \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} \\Cv \\Bv \\right) = - \\tr \\left( \\frac{\\diff \\Av}{\\diff a_{ij}} \\Av^{-1} \\Cv \\Bv \\Av^{-1} \\right) \\end{align*} 注意\\diff \\Av / \\diff a_{ij}是一个(i,j)处为1其余均为0的矩阵，于是 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff a_{ij}} = - [\\Av^{-1} \\Cv \\Bv \\Av^{-1}]_{ji} \\end{align*} 写成矩阵的形式为 \\begin{align*} \\frac{\\diff (\\tr (\\Bv \\Av^{-1} \\Cv))}{\\diff \\Av} = - \\Av^{-\\top} \\Bv^\\top \\Cv^\\top \\Av^{-\\top} \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-07-18 12:55:21 "},"posts/determinant/Cauchy-Binet.html":{"url":"posts/determinant/Cauchy-Binet.html","title":"Cauchy-Binet公式","keywords":"","body":"　　众所周知对于方阵\\Av、\\Bv有 \\begin{align} \\label{eq: det-product} \\det(\\Av \\Bv) = \\det(\\Av) \\det(\\Bv) \\end{align} 更一般的设\\Av \\in \\Rbb^{m \\times n}、\\Bv \\in \\Rbb^{n \\times m}，记S_{[n],m}为集合[n]的所有m元子集构成的集合，则 \\begin{align} \\label{eq: Cauchy-Binet} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align} 这就是Cauchy-Binet公式。 　　考虑三种情况： m = n，此时S_{[n],n}中只有一个元素，就是[n]，式(\\ref{eq: Cauchy-Binet})就退化成了式(\\ref{eq: det-product})； m > n，此时S_{[n],m}是个空集，因此式(\\ref{eq: Cauchy-Binet})等号右边的求和为零，而左边是个秩为n的m阶方阵，非满秩矩阵对应的行列式值为零； m ，举个简单的例子，n=3、m=2、S_{[n],m} = \\{ \\{1,2\\}, \\{2,3\\}, \\{1,3\\} \\}，此时有 \\begin{align*} \\left| \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\end{bmatrix} \\begin{bmatrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{bmatrix} \\right| = \\underbrace{\\left| \\begin{matrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{21} & b_{22} \\end{matrix} \\right|}_{S=\\{1,2\\}} + \\underbrace{\\left| \\begin{matrix} a_{12} & a_{13} \\\\ a_{22} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{21} & b_{22} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{2,3\\}} + \\underbrace{\\left| \\begin{matrix} a_{11} & a_{13} \\\\ a_{21} & a_{23} \\end{matrix} \\right| \\left| \\begin{matrix} b_{11} & b_{12} \\\\ b_{31} & b_{32} \\end{matrix} \\right|}_{S=\\{1,3\\}} \\end{align*} 　　下面给出一个简单的证明，记\\Av的列分别为\\av_1, \\ldots, \\av_n，则 \\begin{align*} \\Av \\Bv = \\begin{bmatrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{bmatrix} \\end{align*} 即\\Av \\Bv的每一列都是\\av_1, \\ldots, \\av_n的线性组合。下面依次展开每一列，易知 \\begin{align*} \\det(\\Av \\Bv) & = | \\begin{matrix} \\sum_i b_{i1} \\av_i & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\\\ & = b_{11} | \\begin{matrix} \\av_1 & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n1} | \\begin{matrix} \\av_n & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | \\end{align*} 接着展开第二列，易知上式右边的每一项又会拆分成n项，即 \\begin{align*} \\forall k \\in [n], \\quad & b_{k1} | \\begin{matrix} \\av_k & \\sum_i b_{i2} \\av_i & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | = b_{k1} (b_{12} | \\begin{matrix} \\av_k & \\av_1 & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} | + \\cdots + b_{n2} | \\begin{matrix} \\av_k & \\av_n & \\ldots & \\sum_i b_{im} \\av_i \\end{matrix} |) \\end{align*} 最终全部m列展开完毕，将会得到n^m项： \\begin{align*} \\det(\\Av \\Bv) = \\sum_{\\phi} b_{\\phi(1),1} b_{\\phi(2),2} \\cdots b_{\\phi(m),m} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | \\end{align*} 其中\\phi是[m] \\mapsto [n]的映射，求和遍历所有这样的映射。注意若行列式两列相同，行列式值为零，因此实际我们只需考虑单射，这样上式的求和项中就只剩下A_n^m项。 　　对于任一满足\\phi(1) 的项，显然它的行列式中的部分是\\Av的某个m阶子方阵，故 \\begin{align*} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = \\det(\\Av_{[m], S}) \\end{align*} 其中S = \\{\\phi(1), \\phi(2), \\ldots, \\phi(m)\\}。现考虑其它行列式也由\\av_{\\phi(1)}, \\ldots, \\av_{\\phi(m)}构成的项，这样的项有m!个，均呈型 \\begin{align*} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | \\end{align*} 其中\\sigma是S \\mapsto S的置换，由于行列式交换两列，值不变符号取反，因此 \\begin{align*} | \\begin{matrix} \\av_{\\sigma \\circ \\phi(1)} & \\av_{\\sigma \\circ \\phi(2)} & \\ldots & \\av_{\\sigma \\circ \\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} | \\begin{matrix} \\av_{\\phi(1)} & \\av_{\\phi(2)} & \\ldots & \\av_{\\phi(m)} \\end{matrix} | = (-1)^{\\sgn (\\sigma)} \\det(\\Av_{[m], S}) \\end{align*} 其中\\sgn (\\sigma)是\\sigma产生的逆序对的个数。所有这样的项求和为 \\begin{align*} \\left( \\sum_{\\sigma} (-1)^{\\sgn (\\sigma)} b_{\\sigma \\circ \\phi(1),1} b_{\\sigma \\circ \\phi(2),2} \\cdots b_{\\sigma \\circ \\phi(m),m} \\right) \\det(\\Av_{[m], S}) \\end{align*} 注意括号中的部分就是\\Bv的第\\phi(1), \\ldots, \\phi(m)行构成的m阶子方阵的行列式展开，因此上式等于 \\begin{align*} \\det(\\Av_{[m], S}) \\det(\\Bv_{S,[m]}) \\end{align*} 取遍C_n^m个这样单调递增的\\phi即可得 \\begin{align*} \\det(\\Av \\Bv) = \\sum_{S \\in S_{[n],m}} \\det(\\Av_{[m],S}) \\det(\\Bv_{S,[m]}) \\end{align*} Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-07-09 08:55:45 "},"posts/measure/set-ring-algebra-ring.html":{"url":"posts/measure/set-ring-algebra-ring.html","title":"此环非彼环乎？","keywords":"","body":"　　学测度论时会碰到某个非空集合\\Omega的子集构成的集合\\Acal \\subseteq \\Pcal(\\Omega)，当其满足(1).\\emptyset \\subseteq \\Acal；(2).\\Acal关于\\setminus封闭；(3).\\Acal关于\\cup封闭，称为环(ring)。众所周知抽象代数里有个数学结构也叫环，其上定义了加法、乘法两个二元运算，并且关于加法构成交换群(commutative group)，关于乘法构成半群(semigroup)，乘法对加法满足分配律。 　　为了区别，下面我们称前者为集合环，后者为代数环。本文说明两者的关系是\\Acal能通过赋予合适的集合上的加法、乘法构成代数(交换)环当且仅当\\Acal是集合环。 　　\\Leftarrow较为简单，给出具体的加法、乘法定义再验证满足代数环公理即可。定义集合环\\Acal中的加法为对称差： \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X), \\quad \\forall X, Y \\in \\Acal \\end{align*} 不难验证(\\Acal, \\Delta)构成交换群，其中交换律是显然的，封闭性由集合环关于\\setminus、\\cup封闭保证，又 \\begin{align*} X \\Delta \\emptyset & = (X \\setminus \\emptyset) \\cup (\\emptyset \\setminus X) = X \\\\ X \\Delta X & = (X \\setminus X) \\cup (X \\setminus X) = \\emptyset \\end{align*} 因此\\emptyset是单位元，逆元就是自身，结合律(X \\Delta Y) \\Delta Z = X \\Delta (Y \\Delta Z)通过集合运算进行验证较为繁琐，根据下面的Venn图易知其成立。 　　定义乘法为\\cap，于是交换律、结合律都是显然的，由于X \\setminus Y = X \\cap \\complement Y，因此 \\begin{align*} X \\setminus (X \\setminus Y) = X \\setminus (X \\cap \\complement Y) = X \\cap \\complement (X \\cap \\complement Y) = X \\cap (\\complement X \\cup Y) = X \\cap Y \\end{align*} 即封闭性也是满足的(这也说明集合环关于\\cup、\\cap、\\setminus都是封闭的)。 　　最后验证\\Delta对于\\cap满足分配律，由于 \\begin{align*} X \\Delta Y = (X \\setminus Y) \\cup (Y \\setminus X) = (X \\cap \\complement Y) \\cup (Y \\cap \\complement X) = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\end{align*} 于是 \\begin{align*} (X \\Delta Y) \\cap Z & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) \\cap Z \\\\ & = (X \\cup Y) \\cap (\\complement X \\cup \\complement Y \\cup \\complement Z) \\cap Z \\\\ & = [(X \\cup Y) \\cap Z] \\cap [\\complement X \\cup \\complement Y \\cup \\complement Z] \\\\ & = [(X \\cap Z) \\cup (Y \\cap Z)] \\cap [\\complement (X \\cap Z) \\cup \\complement(Y \\cap Z)] \\\\ & = (X \\cap Z) \\Delta (Y \\cap Z) \\end{align*} 同理易知有 \\begin{align*} Z \\cap (X \\Delta Y) = Z \\cap (X \\cup Y) \\cap (\\complement X \\cup \\complement Y) = (X \\cap Z) \\Delta (Y \\cap Z) = (Z \\cap X) \\Delta (Z \\cap Y) \\end{align*} 综上，若\\Acal \\subseteq \\Pcal(\\Omega)是集合环，则(\\Acal, \\Delta, \\cap)构成代数(交换)环。 　　\\Rightarrow较为复杂，因为我们不知道一个有望构成交换环的集合，它对应的加法、乘法分别是啥，所以我们得先把加法、乘法构造出来。 　　先考虑二元集合R = \\{0, 1\\}构成的交换环(R, +, \\times)，不妨设加法单位元是0，由交换律可知 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1 \\end{align*} 若1 + 1 = 1，则1没有逆元，故1 + 1 = 0，不难验证这样定义的(R, +)构成交换群。由于\\times对+满足分配律，因此 \\begin{align*} 0 \\times 0 = (0 + 0) \\times 0 = 0 \\times 0 + 0 \\times 0 & \\Longrightarrow 0 \\times 0 = 0 \\\\ 0 \\times 1 = (0 + 0) \\times 1 = 0 \\times 1 + 0 \\times 1 & \\Longrightarrow 0 \\times 1 = 0 \\\\ 1 \\times 0 = 1 \\times (0 + 0) = 1 \\times 0 + 1 \\times 0 & \\Longrightarrow 1 \\times 0 = 0 \\end{align*} 最后1 \\times 1无论等于0还是1，(R, \\times)均可构成半群。因此二元集合可构成两种环，加法均为 \\begin{align*} 0 + 0 = 0, \\quad 0 + 1 = 1 + 0 = 1, \\quad 1 + 1 = 0 \\\\ \\end{align*} 乘法分别为 \\begin{align*} 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 0 \\\\ 0 \\times 0 = 0, \\quad 0 \\times 1 = 1 \\times 0 = 0, \\quad 1 \\times 1 = 1 \\end{align*} 即只在1 \\times 1的结果上有区别。若加法单位元是1，上述所有运算结果的0和1互换位置，整体结构不变。 　　设R^\\Omega = \\{ f: \\Omega \\mapsto R \\}，由R的特性知每个f都是将\\Omega中的一部分元素映射为0，剩下映射为1，因此R^\\Omega中共有|\\Pcal(\\Omega)|个元素，每个元素均是\\Omega某个子集的特征函数： \\begin{align*} R^\\Omega = \\{ 1_X \\mid X \\in \\Pcal(\\Omega) \\} \\end{align*} 这样就在R^\\Omega和\\Pcal(\\Omega)间建立了一一对应，即g: 1_X \\mapsto X是一个双射。若R^\\Omega想构成环，其上的加法、乘法只能由R上的加法、乘法导出： \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) \\triangleq 1_X(a) + 1_Y(a) \\\\ \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) \\triangleq 1_X(a) \\times 1_Y(a) \\end{align*} 　　根据R上的加法规则有 \\begin{align*} \\oplus: ~ & (1_X,1_Y) \\mapsto (1_X \\oplus 1_Y) (a) = \\begin{cases} 0 + 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 + 0 = 1 & \\forall a \\in X \\setminus Y \\\\ 0 + 1 = 1 & \\forall a \\in Y \\setminus X \\\\ 1 + 1 = 0 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 即R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{X \\Delta Y} \\end{align*} 两个集合的特征函数的加和等于其对称差的特征函数。R上的乘法规则不唯一 \\begin{align*} \\otimes: ~ & (1_X,1_Y) \\mapsto (1_X \\otimes 1_Y) (a) = \\begin{cases} 0 \\times 0 = 0 & \\forall a \\in \\Omega \\setminus (X \\cup Y) \\\\ 1 \\times 0 = 0 & \\forall a \\in X \\setminus Y \\\\ 0 \\times 1 = 0 & \\forall a \\in Y \\setminus X \\\\ 1 \\times 1 = 0~\\text{或}~1 & \\forall a \\in X \\cap Y \\end{cases} \\end{align*} 前者对应任何两个集合的特征函数的乘积都是空集的特征函数，后者对应乘积是交集的特征函数： \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\emptyset ~\\text{或}~ 1_{X \\cap Y} \\end{align*} 　　若R上的加法单位元是1，运算规则中的0和1互换位置，因此导出的R^\\Omega上的加法规则为 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)} \\end{align*} 同样乘法规则不唯一，其中一个对应任何两个集合的乘积都是全集的特征函数，另一个对应乘积是交集的补集的特征函数，即 \\begin{align*} (1_X,1_Y) \\mapsto 1_X \\otimes 1_Y = 1_\\Omega ~\\text{或}~ 1_{\\complement (X \\cap Y)} \\end{align*} 即在前者的基础上多个取补集的操作(空集的补集是全集)。 　　至此给出了R^\\Omega可能构成的四种交换环 \\begin{align*} & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_\\emptyset) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{X \\Delta Y}, 1_X \\otimes 1_Y = 1_{X \\cap Y}) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_\\Omega) \\\\ & (R^\\Omega, 1_X \\oplus 1_Y = 1_{\\complement (X \\Delta Y)}, 1_X \\otimes 1_Y = 1_{\\complement (X \\cap Y)}) \\end{align*} 注意对于第二种交换环有 \\begin{align*} g(1_X \\oplus 1_Y) & = g(1_{X \\Delta Y}) = X \\Delta Y = g(1_X) \\Delta g(1_Y) \\\\ g(1_X \\otimes 1_Y) & = g(1_{X \\cap Y}) = X \\cap Y = g(1_X) \\cap g(1_Y) \\end{align*} 即(\\Pcal(\\Omega), \\Delta, \\cap)同构于(R^\\Omega, \\oplus, \\otimes)，也构成交换环，其他情形没有如此简洁的对应(常用的二元集合运算没有结果恒为空集、全集或两者对称差、交集的补集，除非重新定义)。 　　对\\forall \\Acal \\subseteq \\Pcal(\\Omega)，若其能够构成代数环，则(\\Acal, \\Delta, \\cap)应为(\\Pcal(\\Omega), \\Delta, \\cap)的子环，即\\Acal对\\Delta、\\cap保持封闭，于是对\\forall X, Y \\in \\Acal有 \\begin{align*} \\emptyset & = X \\Delta X \\in \\Acal \\\\ X \\setminus Y & = (X \\Delta Y) \\cap X \\in \\Acal \\\\ X \\cup Y & = (X \\Delta Y) \\Delta (X \\cap Y) \\in \\Acal \\end{align*} 因此\\Acal是集合环。 Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2020-08-18 20:04:17 "}}